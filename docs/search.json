[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "mrgsolve user guide",
    "section": "",
    "text": "Introduction\nWelcome to the mrgsolve user guide. The user guide is the main documentation source for how mrgsolve works and how to best use mrgsolve in your modeling and simulation project. As with most of the mrgsolve documentation, this is a work in progress. I am currently working to transition this to more of a reference resource, rather than demonstration. So key content in the user guide includes Chapter 2 on model specification, Chapter 1 on model components and Chapter 7 on the simulation sequence. Installation is a big topic but we defer to the wiki page for installation help since requirements tend to change frequently with new R releases. The other content is hopefully helpful as well. I’m leaving it all in place for now, but will gradually transition the “how-to” and demo type content over to the vignettes repository or the gallery repository (see below).\nPlease feel free to ask questions about anything mrgsolve-related on the issue tracker on the main github repo: https://github.com/metrumresearchgroup/mrgsolve/issues."
  },
  {
    "objectID": "index.html#overview",
    "href": "index.html#overview",
    "title": "mrgsolve user guide",
    "section": "Overview",
    "text": "Overview\nIf you are accessing the user guide via html, you should be able to see a table of contents on the left. That has a lot of detail in there so I’m going to give you high-level overview of what is here (the high-level should be pretty clear in the pdfbook).\n\nChapter 1 tells you about what is in the mrgsolve model object (like parameters, compartments, C++ functions and the like)\nChapter 2 tells you about model specification. There are two main sections to this chapter: Section 2.2) lists the different model code blocks and Section 2.3) lists the different variables that you can get (or set) in the different code blocks\nChapter 3 shows you how to format input data sets\nChapter 4 shows you how to create and work with simple data set objects called event objects\nChapter 5 shows how to work with model matrices\nChapter 6 tells you about the simulated output object and how you can work with it\nChapter 7 dives into the simulation sequence, showing you the steps that mrgsolve takes to work through a problem\nChapter 8 gives the details on how mrgsolve advances the system to a pharmacokinetic steady state\nChapter 9 talks about different plugins you can use for more advanced modeling\nChapter 10 talks about modeled events (discontinuities in the simulation that are triggered from within the model rather than from the data set)\nChapter 11 is a collection of applied examples on different topics\nChapter 12 are brief questions and answers providing some bits of information that don’t obviously fit into another chapter\nChapter 13 provides links to some Wiki pages that can help with installation"
  },
  {
    "objectID": "index.html#pdf-version",
    "href": "index.html#pdf-version",
    "title": "mrgsolve user guide",
    "section": "PDF Version",
    "text": "PDF Version\nThis book is also available in pdf format here."
  },
  {
    "objectID": "index.html#other-resources",
    "href": "index.html#other-resources",
    "title": "mrgsolve user guide",
    "section": "Other Resources",
    "text": "Other Resources\n\nMain resource page: mrgsolve.github.io\nVignettes: mrgsolve.github.io/vignettes\nR documentation: mrgsolve.github.io/docs\nGallery: github.com/mrgsolve/gallery\n\n\nThis book was assembled on Thu Aug 17 16:12:29 2023 with mrgsolve version 1.1.1."
  },
  {
    "objectID": "components.html#sec-component-param",
    "href": "components.html#sec-component-param",
    "title": "1  Model components",
    "section": "1.1 Parameter list",
    "text": "1.1 Parameter list\nThe parameter list is an updatable set of name-value pairs. Referencing the name of an item in the parameter list will substitute the current value associated with that name. While the name “parameter” may have a certain connotation in the modeling world, in mrgsolve a “parameter” could be any category of numeric data: covariates (e.g. WT, AGE, SEX), flags, other numeric data that we commonly call “parameter” (e.g. CL or VC).\nThe parameter list is declared in the code block $PARAM. While there may be multiple $PARAM blocks in a model, these are condensed to a single parameter list stored in the model object. The names and numbers of all parameters in the model must be declared at the time that the model is compiled. Also, a default value for each parameter must be declared at model compile time, but the value of each parameter may be updated in one of several ways.\nThe parameters in a model object can be queried or updated with the param() function.\nSee also: Section 2.2.4, ?param in the R help system after loading mrgsolve.\n\n1.1.1 Central role of parameters in planning simulations\nThe data items in the parameter list are more than just values associated with a name. When an name is added to the parameter list, that name becomes a key word that mrgsolve will start to recognize in input data sets or when manipulating the model object.\nFor example, when you want to include a covariate in the model, say weight (WT), you’ll include a column in the data set called WT that will indicate the weight of this or that patient. It is crucial that you also list WT in $PARAM with some default value. It helps if that value is sensible too. When mrgsolve receives the data set prior to simulating, the WT column is matched up with the WT parameter name. As mrgsolve works its way through the input data set (from person to person or from time to time), the value of WT is updated so that the symbol WT in $MAIN or $ODE or $TABLE always points to the value of WT. If the WT name is not in the parameter list, it won’t matter if it is in the data set or not. Only listing a name in $PARAM gets it “into the game”.\nUnderstanding the parameter update mechanism is very important for planning complicated simulations with mrgsolve. Please see the information in Section 3.1 and in Section 11.3."
  },
  {
    "objectID": "components.html#sec-component-init",
    "href": "components.html#sec-component-init",
    "title": "1  Model components",
    "section": "1.2 Compartment list",
    "text": "1.2 Compartment list\nLike the parameter list, the compartment list is a series of name-value pairs. The compartment list defines the number, names, and initial values of each compartment in the model. The names, numbers, and order of the compartment in a model is established at the time of model compile and changes to the compartment list require re-compilation of the model.\nCompartments are declared in one of two code blocks: $INIT and $CMT. Nominal initial values must be supplied for each compartment. The main difference between $INIT and $CMT is that $CMT assumes a default initial value of 0 for each compartment; thus only compartment names are entered. When using $INIT, both names and values must be explicitly stated for each compartment.\nThe initial values for each compartment can be queried with the init() function. There are several different ways to set the initial conditions in a model; Section 11.2 illustrates several of these.\nSee also: Section 11.2 and ?init in the R help system after loading mrgsolve."
  },
  {
    "objectID": "components.html#sec-component-stime",
    "href": "components.html#sec-component-stime",
    "title": "1  Model components",
    "section": "1.3 Simulation time grid",
    "text": "1.3 Simulation time grid\nThe mrgsolve model object stores the parameters for the series of time points to be output for a a simulation. This is the default output time grid that will be used if not over-ridden by another mechanism.\nThe elements of the simulation time grid are: start, end, delta and add. start, end, delta are passed to seq() as from, to, and by, respectively. add is any arbitrary vector of additional times to simulate.\nThe simulation time grid in a model object may be queried with the stime() function or by printing the model object to the R console.\nSee also Section 3.2 for discussion of the simulation time grid and input data sets and Section 1.3.1 and Section 11.4 for using time grid objects .\n\n1.3.1 tgrid objects\nA tgrid object has start, end, delta and add attributes. This object is independent of the model object. tgrid objects may be created and combined to create complex sampling designs.\nSee Section 11.4 for examples and usage."
  },
  {
    "objectID": "components.html#solver-settings",
    "href": "components.html#solver-settings",
    "title": "1  Model components",
    "section": "1.4 Solver settings",
    "text": "1.4 Solver settings\nmrgsolve uses the DLSODA solver like the one from ODEPACK. Several of the settings for that solver are stored in the model object and passed to the solver when the problem is started. Settings include: atol, rtol, maxsteps, hmax, hmin, ixpr, mxhnil.\nSolver settings can be changed through the update() method for your mrgsolve model object. For example, to change rtol to 1e-5, write\n\nmod <- update(mod, rtol = 1e-5)\n\nwhere mod is your mrgsolve model object.\n\n1.4.1 atol\nAbsolute tolerance parameter. Adjust this value lower when you see state variables (compartments) that are becoming very small and possibly turning negative. For example:\n\nmod <- modlib(\"viral1\", end = 144) \n\nout <- mrgsim_e(mod, ev(amt = 1000)) %>% filter(V < 0)\n\nout\n\n. # A tibble: 12 × 8\n.       ID  time expos        T         I         V  logV logChange\n.    <dbl> <dbl> <dbl>    <dbl>     <dbl>     <dbl> <dbl>     <dbl>\n.  1     1  95    1000 5187630. -1.79e-11 -1.16e-13   NaN       NaN\n.  2     1  97.5  1000 5298189. -1.92e-10 -1.26e-12   NaN       NaN\n.  3     1 100    1000 5407830. -2.44e-10 -1.60e-12   NaN       NaN\n.  4     1 102.   1000 5516561. -2.75e-10 -1.80e-12   NaN       NaN\n.  5     1 105    1000 5624390. -1.78e-10 -1.17e-12   NaN       NaN\n.  6     1 108.   1000 5731324. -8.56e-11 -5.60e-13   NaN       NaN\n.  7     1 110    1000 5837370. -1.24e-11 -8.12e-14   NaN       NaN\n.  8     1 122.   1000 6354547. -1.67e-11 -1.10e-13   NaN       NaN\n.  9     1 125    1000 6455421. -1.91e-11 -1.25e-13   NaN       NaN\n. 10     1 128.   1000 6555459. -2.11e-11 -1.38e-13   NaN       NaN\n. 11     1 130    1000 6654666. -1.23e-11 -8.07e-14   NaN       NaN\n. 12     1 132.   1000 6753050. -2.75e-12 -1.82e-14   NaN       NaN\n\n\nAdjusting atol to 1E-20 or 1E-30 will prevent this.\n\nmrgsim_e(mod, ev(amt = 1000), atol = 1E-20)  %>% filter(time %in% out$time)\n\n. # A tibble: 12 × 8\n.       ID  time expos        T        I        V  logV logChange\n.    <dbl> <dbl> <dbl>    <dbl>    <dbl>    <dbl> <dbl>     <dbl>\n.  1     1  95    1000 5187630. 1.33e-11 8.72e-14 -13.1     -18.7\n.  2     1  97.5  1000 5298189. 5.13e-12 3.36e-14 -13.5     -19.2\n.  3     1 100    1000 5407830. 1.98e-12 1.30e-14 -13.9     -19.6\n.  4     1 102.   1000 5516561. 7.66e-13 5.01e-15 -14.3     -20.0\n.  5     1 105    1000 5624390. 2.96e-13 1.94e-15 -14.7     -20.4\n.  6     1 108.   1000 5731324. 1.15e-13 7.51e-16 -15.1     -20.8\n.  7     1 110    1000 5837370. 4.44e-14 2.91e-16 -15.5     -21.2\n.  8     1 122.   1000 6354547. 3.94e-16 2.58e-18 -17.6     -23.3\n.  9     1 125    1000 6455422. 1.54e-16 1.01e-18 -18.0     -23.7\n. 10     1 128.   1000 6555459. 5.99e-17 3.92e-19 -18.4     -24.1\n. 11     1 130    1000 6654666. 2.34e-17 1.53e-19 -18.8     -24.5\n. 12     1 132.   1000 6753050. 9.14e-18 5.98e-20 -19.2     -24.9\n\n\n\n\n1.4.2 rtol\nRelative tolerance parameter. Adjust this value lower when you want more precision around the calculation of state variables as the system advances.\n\n\n1.4.3 maxsteps\nThis is the maximum number of steps the solver will take when advancing from one time to the next. If the solver can’t make it in maxsteps it will stop and give an error message like this:\n\nDLSODA-  At current T (=R1), MXSTEP (=I1) steps   \n      taken on this call before reaching TOUT     \nIn above message, I = \n[1] 2000\nIn above message, R = \n[1] 0.0004049985\nDLSODA-  ISTATE (=I1) illegal.\nIn above message, I = \n[1] -1\nDLSODA-  Run aborted.. apparent infinite loop.    \nError in (function (x, data, idata = null_idata, carry.out = character(0),  : \n  error from XERRWD\n\nYou might see this when you have to integrate along time between records in a data set. There isn’t necessarily a problem, but the solver might have to advance over many doses to get to the next record and it only has a limited number of steps it can take between those records before it stops with this error.\nWhen you see this, increase maxsteps to 50000 or larger.\nBut keep in mind that sometimes the solver can’t make it to the next record because there are issues with the model. It might take thousands of steps to make it 24 hours down the road. In that case, go back to the model code and look for problems in how it is coded.\n\n\n1.4.4 hmax\nThe maximum step size. By default, the solver will take steps of different sizes based on what is happening in the simulation. Setting hmax tells the solver not to take a step larger than that value. So in a model where time is in hours, reducing hmax to 0.1 will prevent the solver from taking a step larger than 0.1 hours as it tries to advance to the next time. The will slow down the simulation a bit. But sometimes helpful when the solver starts taking large steps. We don’t recommend using this routinely; for most applications, it should be reserved for troubleshooting situations. If your model doesn’t give the results that you want without setting hmax, we’d recommend a new setup where this isn’t needed.\n\n\n1.4.5 hmin\nThe minimum step size. Only set this if you know what you’re doing.\n\n\n1.4.6 ixpr\nA flag to enable printing messages to the R console when the solver switches between non-stiff and stiff solving modes. Rarely used.\n\n\n1.4.7 mxhnil\nThe maximum number of messages printed when the model is solving. If you have a lot of messages, keep working on your model code."
  },
  {
    "objectID": "components.html#sec-model-functions",
    "href": "components.html#sec-model-functions",
    "title": "1  Model components",
    "section": "1.5 Functions  ",
    "text": "1.5 Functions  \nThere are four C++ functions that mrgsolve creates and manages: PREAMBLE, MAIN, ODE, TABLE. Each function is created from an entire code block in the model specification file. The user is responsible for writing correct C++ code in each of these blocks. mrgsolve will parse these blocks and augment this code with the necessary elements to create the C++ function.\nThese functions may be specified in any order in the model specification file, but there is a specific calling order for these functions. Recognizing and understanding this calling order will help understand how the different pieces of the model specification fit together.\nJust prior to starting the problem, mrgsolve calls $PREAMBLE. Then, during advance from time T1 to T2, first $MAIN is called, then $ODE is called repeatedly as the solver finds the values of state variables at T2, and, once the solution is found, $TABLE is called to calculate derived quantities at T2 and to specify variables that should be included in the model output. So, it is helpful to write model specification files in the order:\n\n$PREAMBLE - called only once just prior to processing the first record of the data set\n$MAIN - before advancing the system\n$ODE - the system advances to T2\n$TABLE - after advancing the system\n\nBut the order in which they are coded will not affect model compilation or the simulation result.\n\n1.5.1 The $PREAMBLE function\nThe PREAMBLE function gets called only once, just prior to processing the first record of the data set. This function is composed of C++ code and is used to initialize variables and get them set up prior to starting on the problem.\nSee Section 2.2.14 for details.\n\n\n1.5.2 The $MAIN function\nThe MAIN function gets called at least once before the the solver advances from the current time (T1) to the next time (T2). In the MAIN function, the user may:\n\nSet initial conditions for any compartment\nDerive new variables to be used in the model\nWrite covariate models\nAdd between-subject variability to quantities to structural model parameters (e.g. CL or VC).\n\nIn addition to getting called once per record, the MAIN function may be called several times prior to starting the simulation run. The MAIN function is also called whenever the user queries the compartment list.\nmrgsolve allows you access compartment amounts in the MAIN function. But it is important to remember the calling order of these model functions (Section 1.5): because MAIN is called before the system advances, the compartment amounts inside this function will reflect the pre-advance values. This is in contrast to accessing compartment amounts inside the TABLE function, which will reflect the values after the system advances. While there are some use cases where it is useful to check the pre-advance compartment amounts in MAIN, most applications should interact with compartment amounts after the system advances in TABLE.\nThe MAIN block contains code that is equivalent to the code you’d write in NONMEM’s $PK block. You can use either $MAIN or $PK in your mrgsolve model.\nSee Section 2.2.8 and Section 2.2.9 for details.\n\n\n1.5.3 The $ODE function\nThe ODE function is where the user writes the model differential equations. Any derived quantity that depends on a state variable and is used to advanced the system must be calculated inside $ODE. But, this function is called repeatedly during the simulation run, so any calculation that can be moved out of $ODE (for example: to $MAIN) should be.\nThe ODE block contains code that is equivalent to the code you’d write in NONMEM’s $DES block. You can use either $ODE or $DES in your mrgsolve model.\nSee Section 2.2.10 and Section 2.2.11 for details.\n\n\n1.5.4 The $TABLE function\nThe TABLE function is called after the solver advances in time. The purpose of TABLE is to allow the user to interact with the values of the state variables after advancing, potentially derive new variables, and to insert different outputs into the table of simulated results.\nThe TABLE block contains code that is equivalent to the code you’d write in NONMEM’s $ERROR block. You can use either $TABLE or $ERROR in your mrgsolve model.\nSee Section 2.2.12 and Section 2.2.13 for details."
  },
  {
    "objectID": "components.html#random-effect-variances",
    "href": "components.html#random-effect-variances",
    "title": "1  Model components",
    "section": "1.6 Random effect variances",
    "text": "1.6 Random effect variances\nThe mrgsolve model object keeps track of a arbitrary number of block matrices that are used to simulate variates from multivariate normal distributions. Users can specify OMEGA matrices for simulating between-subject random effects (one draw per individual) or SIGMA matrices for simulating within-subject random effects (one draw per observation).\nSee Chapter 5 for complete details on how to work with OMEGA and SIGMA in your mrgsolve model.\n\n1.6.1 OMEGA\nThe matrices are specified in $OMEGA blocks in the model specification file.\nOMEGA may be queried or updated with the omat() function.\n\n\n1.6.2 SIGMA\nThe matrices are specified in $SIGMA blocks in the model specification file.\nSIGMA may be queried or updated by the smat() function."
  },
  {
    "objectID": "specification.html#how-where-to-write-a-model",
    "href": "specification.html#how-where-to-write-a-model",
    "title": "2  Model specification",
    "section": "2.1 How / where to write a model",
    "text": "2.1 How / where to write a model\nThere are two ways to write your model:\n\nCode in a separate file and source into your R script\nCode inline as a character string already in your R script\n\nWe recommend method 1 (separate file) for any non-trivial modeling work. Method 2 is handy for quickly coding a model and you’ll also see us using that approach frequently when demonstrating how to use mrgsolve.\n\n2.1.1 Separate file\nFor most applications, you will want to put your model code in a standalone file. This file can have any extension, but there is some special behavior when you use the .cpp extension. We’ll show you both here.\n\n2.1.1.1 Using .cpp file extension\nOpen a text editor and type the model code into a file with name that has the format <model-name>.cpp. This filename format identifies a “name” for your model (<model-name>, the “stem” of the file name). Note: this whole file will be read and parsed, so everything in it must be valid mrgsolve model specification elements.\nUse the mread() function to read and parse this file. For the model called mymodel saved in mymodel.cpp (in the current working directory), issue the command:\n\nmod <- mread(\"mymodel\")\n\nmread() returns a model object from which you can simulate.\n\n\n2.1.1.2 Using any file extension\nYou can use any file extension to save your mrgsolve model. Rather than using .cpp, you might use .mod. When you are using an extension other than .cpp, pass in the entire file name, both stem and extension. If you have the model code saved in mymodel.mod then you’d call\n\nmod <- mread(\"mymodel.mod\")\n\nto load that model.\n\n\n2.1.1.3 The model project directory\nThe second argument to mread() is project. This is the directory where mrgsolve will look for your model file (passed as the first argument to mread()).\nIf your myproject.mod file is located in the models directory, then you could load that file with\n\nmod <- mread(\"mymodel.mod\", project = \"models\")\n\nAlternatively, you can just past the entire path to the model file\n\nmod <- mread(\"models/mymodel.mod\")\n\n\n\n\n2.1.2 Inline / code  \nOften it is more convenient to write a model right in your R script. The model might look something like this:\n\ncode <- '\n$PARAM CL = 1, VC = 20\n$PKMODEL ncmt=1\n'\n\nHere, we created a character vector of length 1 and saved it to the R object called code. The name of this object is irrelevant. But code will be passed into mrgsolve as the model definition. When mrgsolve gets a model like this along with a “name” for the model, mrgsolve will write the code to a file called <model-name>.cpp and read it right back in as if you had typed the code into this file (Section 2.1.1).\nTo parse and load this model, use the mcode() command:\n\nmod <- mcode(\"mymodel\", code)\n\nmcode() is a convenience wrapper for mread(). mcode writes the code to mymodel.cpp in tempdir(), reads it back in, compiles and loads.\nThe mcode call is equivalent to:\n\nmod <- mread(\"mymodel\", tempdir(), code)\n\nFor help, see ?mread , ?mcode in the R help system after loading mrgsolve.\n\n\n2.1.3 Comments\nYou can comment out code in the model specification file with two front slashes //\n\n$MAIN\n\ndouble a = 1.234;\n// double b = 5.678; \n\nThis comment sequence is what is used in C++ code, but you can use it anywhere in the mrgsolve model specification file."
  },
  {
    "objectID": "specification.html#sec-code-blocks",
    "href": "specification.html#sec-code-blocks",
    "title": "2  Model specification",
    "section": "2.2 Code blocks",
    "text": "2.2 Code blocks\n\n2.2.1 About code blocks\nBlock identifier\nDifferent types of code are organized in the model specification file and separated by block identifiers. There are two ways to formulate block identifiers that can be used in mrgsolve. In the first type, a dollar-sign is placed at the start of the block name\n\n$BLOCKNAME\n<block-code>\n\nFor example, a block of parameters would be\n\n$PARAM\nCL = 1\n\nThe second way to write this is with brackets\n\n[ BLOCKNAME ] \n<block-code>\n\nThere is no functional difference between the dollar-sign notation and the brackets. When model specification code is saved into a file with a .cpp extension, the code editor may make certain assumptions about formatting or styling the code. Using brackets will most-likely work better with the editor in that case.\nBlock identifiers are case-insensitive so all of these also work\n\n$param \nCL = 1\n\n\n[ param ] \nCL = 1\n\nUsers are free to include block code on the same line as the block identifier, but must include a space after the identifier. For example, the parser will recognize $PARAM CL = 1 but not $PARAMCL=1 as parameters.\nBlock syntax Different blocks may require different syntax. For example, code written in $PARAM will be parsed by the R parser and will generally need to adhere to R syntax requirements. On the other hand, code in $MAIN, $ODE, and $TABLE will be used to make functions in C++ and therefore will need to be valid C++ code, including terminal ; on each line.\nBlock options Options may be specified on some code blocks that signal how the code is to be parsed or used in the simulation.\nBlock options can be boolean in which case you indicate the option name with nothing following. For example, to indicate block = TRUE for an OMEGA matrix, write\n\n$OMEGA @block \n1 2 3\n\nHere @block indicates block = TRUE. Starting with mrgsolve 1.0.0, block options can be negated by writing ! between @ and the option name. To request a non-block (diagonal) OMEGA matrix\n\n$OMEGA @!block \n1 2 3\n\nBut note well that diagonal is the default configuration for OMEGA, so it is never necessary to write this.\nOther non-boolean block options state the name and then a value to be assigned to that name. For example, if we wanted to assign labels to the ETAs from an OMEGA block, we’d write\n\n$OMEGA @labels ECL EVC\n1 2\n\nThis essentially sets labels equal to the vector c(\"ECL\", \"EVC\").\nWe note two specific boolean options (@object and @as_object) that have similar function across multiple blocks.\n\n\n2.2.2 Programmatic or bulk initialization\nThe following describes syntax for initializing blocks as R objects using R code. This can be helpful, say, when you need to initialize a 50x50 OMEGA matrix or a series of systematically named parameters. We will describe the @object and @as_object options that are available on select blocks.\nThe @object option lets you name an object defined in $ENV to use to instantiate the block data. For example, to specify a series of parameters using the @object option, you’d write\n\n$ENV\nparams <- list(CL = 1, V = 20, KA = 1.2)\n\n$PARAM @object params\n\nThis tells mrgsolve that there is an object called params that it is in the $ENV environment and mrgsolve will use that to define the names and values. This is a trivial example to show how a simple series of parameters could be defined. However, the intended use for this functionality is to allow efficient creation of a large, systematically-named series of parameters in a large model.\nThe @as_object option is a boolean option that tells mrgsolve that the block code will actually return the object (rather than asking mrgsolve to look in $ENV for the object). The equivalent specification for the block above would be:\n\n$PARAM @as_object\nlist(CL = 1, V = 20, KA = 1.2)\n\nThe following blocks contain both the @object and @as_object options:\n\n$PARAM\n$INPUT\n$THETA\n$CMT\n$INT\n$OMEGA\n$SIGMA\n\nPlease see the specific block documentation for more details on the specific type of object that should be returned when this syntax is invoked.\n\n\n2.2.3 $PROB  \nSyntax: text\nMultiple allowed: yes\nOptions: @annotated, @covariates\nUse this block to make notes about the model. There are no restrictions on the text that gets entered here. mrgsolve does not routinely process the text in any way, except when rendering the model as a document. Frequently, we write the text here in markdown format so that it will render nicely in the model document. But this is completely optional.\nSee the annotated model in Section 11.1 for an example.\n\n\n2.2.4 $PARAM  \nSyntax: R\nMultiple allowed: yes\nOptions: @annotated, @covariates, @tag, @input, @object, @as_object\nDefine the parameter list in the current model. Parameters are names associated with values that can be used throughout the model. A value must be given for every parameter name. Names (and numbers) of parameters must be set at the time the model is compiled, but parameter values may be updated without re-compiling the model.\nThe @covariates option allows you to tag a collection of parameters as “covariates”. It does not change the functionality of the model or simulation workflow in any way, but allows you to get that list of covariate names out of the model object.\nThe @input option adds a tag to the parameters in the block so that input data sets will be checked for these parameters when check_data_names() is called. Use the @tag option and supply a user-defined tag that can also be used for checking data sets and parameters.\nExample:\n\n[ PARAM ] CL = 1, VC = 20, KA = 1.2\nKM = 25, VMAX = 400, FLAG = 1, WT = 80\nSEX = 0, N = sqrt(25)\n\nNote that the “values” in the parameter list will get evaluated by the R interpreter and the evaluation will happen inside the environment which is defined by the $ENV block. For example\n\n$ENV NWT = 1.2\n\n$PARAM \nWT = 80 * 2.2\nMASS = 600 * MWT\n\nAnnotated example:\n\n[ PARAM ] @annotated\nCL :   1 : Clearance (L/hr)\nVC :  20 : Volume of distribution (L)\nKA:  1.2 : Absorption rate constant (1/hr)\n\nSee the popex model for an example of using @covariates\n\n\n. \n. Model file: popex.cpp \n. \n. $PARAM\n. TVKA = 0.5, TVCL = 1, TVV = 24\n. \n. $PARAM\n. @covariates\n. WT = 70\n\n\nthen\n\nmod <- modlib(\"popex\")\n\n\nas.list(mod)$covariates\n\n. [1] \"WT\"\n\n\nNotes:\n\nMultiple blocks are allowed\nValues are evaluated by the R interpreter\n\nThe @object and @as_object options should name or return a named list of parameters.\nSee also: Section 2.2.5, Section 2.2.23 and Section 2.2.6.\nSee ?param in the R help system after loading mrgsolve.\n\n\n2.2.5 $INPUT  \nSyntax: R\nMultiple allowed: yes\nOptions: @annotated, @covariates, @tag, @object, @as_object\nThis block operates just like $PARAM (Section 2.2.4), in that it is a way to introduce parameters in to the model. Additionally, the @input tag is added to the model parameters and input data sets will be checked for these parameters when check_data_names() is called.\nSee also: Section 2.2.4, Section 2.2.23, Section 2.2.6.\n\n\n2.2.6 $FIXED  \nSyntax: R\nMultiple allowed: yes\nOptions: @annotated, @object, @as_object\nLike $PARAM, $FIXED is used to specify name=value pairs. Unlike $PARAM, however, the values associated with names in $FIXED are not able to be updated.\nBy default, names in $FIXED are associated with their value through a C++ preprocessor #define statement.\nUsually, $FIXED is only used when there are a very large number of parameters (\\(>\\) 100 or 200). When some of these parameters never need to be updated, you can move them to a $FIXED block to get a modest gain in efficiency of the simulation.\nItems in $FIXED will not be shown when parameters are queried.\nExample:\n\n[ PARAM ] CL = 2, VC = 20\n\n[ FIXED ]\ng = 9.8\n\nAnnotated example:\n\n$FIXED @annotated\ng : 9.8 : Acceleration due to gravity (m/s^2)\n\nSee also: Section 2.2.4 and Section 2.2.23.\nNotes:\n\nMultiple blocks are allowed\nValues are evaluated by the R interpreter\n\n\n\n2.2.7 $CMT and $INIT\nSyntax: text\nMultiple allowed: yes\nOptions: @annotated, @object, @as_object\nDeclare the names of all compartments in the model.\n\nFor $CMT give the names of compartments; initial values are assumed to be 0\nFor $INIT give the name and initial value for all compartments\n\nNote that both $CMT and $INIT declare compartments, so any compartment name should get declared in either $CMT or $INIT, but never both.\nExamples:\n\n[ CMT ] GUT CENT RESPONSE\n\n\n[ INIT ] GUT  = 0, CENT = 0, RESPONSE = 25\n\nAnnotated examples:\n\n[ CMT ] @annotated\nGUT      : Dosing compartment (mg)\nCENT     : Central PK compartment (mg)\nRESPONSE : Response\n\n\n$INIT @annotated\nGUT      :   0 : Dosing compartment (mg)\nCENT     :   0 : Central PK compartment (mg)\nRESPONSE :  25 : Response\n\nThe @object and @as_object options should name or return a named list of compartments and initial values when used in $INIT and a character vector of compartment names when used in $CMT.\nSee ?init in the R help system after loading mrgsolve.\n\n\n2.2.8 $MAIN  \nSyntax: C++\nMultiple allowed: no\nThis code block has two main purposes:\n\nDerive new algebraic relationships between parameters, random, effects and other derived variables\nSet the initial conditions for model compartments\n\nFor users who are familiar with NONMEM, $MAIN is similar to $PK.\n$MAIN is wrapped into a C++ function and compiled / loaded by mrgsolve.\nThe MAIN function gets called just prior to advancing the system from the current time to the next time for each record in the data set. $MAIN also gets called several times before starting the problem (NEWIND == 0) and just prior to simulating each individual (NEWIND == 1). Finally, $MAIN gets called every time the model initial conditions are queried with init().\nNew variables may be declared in $MAIN. See Section 2.5 for details.\nExamples:\n\n[ CMT ] CENT RESP\n\n[ PARAM ] KIN = 100, KOUT = 2, CL = 1, VC = 20\n\n[ MAIN ]\n\nRESP_0 = KIN/KOUT;\n\ndouble ke = CL/VC;\n\n\n\n2.2.9 $PK  \nThis is an alias for $MAIN.\n\n\n2.2.10 $ODE  \nSyntax: C++\nMultiple allowed: no\nOptions: @param\nUse $ODE to define model differential equations. For all compartments assign the value of the differential equation to dxdt_CMT where CMT is the name of the compartment. The dxdt_ equation may be a function of model parameters (via $PARAM), the current value of any compartment (CMT) or any user-derived variable.\nFor example:\n\n[ CMT ] GUT CENT\n\n[ ODE ]\ndxdt_GUT = -KA*GUT;\ndxdt_CENT = KA*GUT - KE*CENT;\n\nIt is important to make sure that there is a dxdt_ expression defined for every compartment listed in $CMT or $INIT, even if it is dxdt_CMT = 0;\nThe $ODE function is called repeatedly during a simulation run. So it is wise to do as many calculations as possible outside of $ODE, usually in $MAIN. But remember that any calculation that depends on an amount in a compartment and helps determine the dxdt_ expression in a model must be written in $ODE.\nNew variables may be declared in $ODE. See Section 2.5 for details.\nFor example:\n\n$CMT CENT RESP\n$PARAM VC = 100, KE = 0.2, KOUT = 2, KIN = 100\n$ODE\ndouble CP = CENT/VC;\ndouble INH = CP/(IMAX+CP)\n\ndxdt_CENT = -KE*CENT;\ndxdt_RESP =  KIN*(1 - INH) - RESP*KOUT;\n\nIf the model needs to refer to the current time, use the SOLVERTIME variable.\nNotes:\n\n$ODE is written in C++ syntax; every line must end in ;\nThere may be only one $ODE block in a model\n\n\n\n2.2.11 $DES  \nThis is an alias for $ODE.\n\n\n2.2.12 $TABLE  \nSyntax: C++\nMultiple allowed: no\nUse $TABLE to interact with parameters, compartment values, and other user-defined variables after the system advances to the next time.\nFor example:\n\n[ TABLE ]\ndouble CP = CENT/VC;\n\nNOTE mrgsolve formerly had a table() macro for inserting derived values into simulated output. This macro has been deprecated. The only way to insert derived values into the simulated output is via $CAPTURE.\nNOTE When variables are marked for capture (see Section 2.2.16), the values of those variables are saved at the end of the $TABLE function. This process is carried out automatically by mrgsolve and therefore requires no user intervention.\n\n\n2.2.13 $ERROR  \nThis is an alias for $TABLE.\n\n\n2.2.14 $PREAMBLE  \nSyntax: C++\nMultiple allowed: no\nThis is the fourth C++ code block. It is called once in two different settings (Chapter 7):\n\nImmediately prior to starting the simulation run\nImmediately prior to calling $MAIN when calculating initial conditions\n\n$PREAMBLE is a function that allows you to set up your C++ environment. It is only called one time during the simulation run (right at the start). The code in this block is typically used to configure or initialize C++ variables or data structures that were declared in $GLOBAL.\nFor example:\n\n[ PLUGIN ] Rcpp\n\n[ GLOBAL ]\nnamespace{\n  Rcpp::NumericVector x;\n}\n\n[ PREAMBLE ]\nx.push_back(1);\nx.push_back(2);\nx.push_back(3);\n\n[ MAIN ]\n<some code that uses x vector>\n\nIn this example, we want to use a numeric vector x and declare it in $GLOBAL so that we can use it anywhere else in the code (the declaration is also made in an unnamed namespace to ensure that the variable is local to the model file). Then, in $PREAMBLE, we put 3 numbers into the vector and we use x in $MAIN. Since $MAIN, $TABLE and (especially) $ODE are called repeatedly as the simulation run progresses, we put the initialization of x in $PREAMBLE to make sure the initialization of x only happens once.\nNotes:\n\n$PREAMBLE is written in C++ syntax; every line must end in ;\nThere may be only one $PREAMBLE block in a model\nLike $MAIN, $ODE and $TABLE, double, int and bool variables initialized in $PREAMBLE are actually initialized for global (within the model file)\n\nSee also: Chapter 7 and Section 2.2.22.\n\n\n2.2.15 $PRED  \nSyntax: C++\nMultiple allowed: no\nUse $PRED to write a model without differential equations. In this block, write all algebraic expressions for derived parameters, the response, and any other derived output quantities.\nFor example:\n\n[ PARAM ] TVE0 = 100, AUC50 = 100, IMAX = 40, AUC = 0\n\n[ PRED ]\ndouble E0 = EVE0*exp(ETA(1));\n\ndouble RESP = E0 - IMAX*AUC/(AUC50+AUC);\n\nIn this example, the entire model is written in the $PRED block. It is an error to include the following blocks when $PRED is being used: $MAIN, $TABLE, $PKMODEL, $ODE, $CMT, $INIT.\nSee Section 3.7 for additional information regarding data sets in use with $PRED block.\n\n\n2.2.16 $CAPTURE  \nSyntax: text\nMultiple allowed: yes\nOptions: @annotated, @etas\nThis is a block to identify variables that should be captured in the simulated output. The @etas option is new with version 1.0.8.\nFor example:\n\n[ PARAM ] A = 1, B = 2\n\n[ MAIN ]\ndouble C = 3;\nbool yes = true;\n\n[ CAPTURE ] A B C yes\n\nThis construct will result in four additional columns in the simulated output with names A, B, C, and yes.\nUsers can also rename captured variables by providing a newname = oldname specification.\n\n$PARAM WT = 70, THETA1 = 2.2\n\n$MAIN\ndouble CL = THETA1*pow(WT/70,0.75)*exp(ETA(1));\n\n$OMEGA 1\n\n$CAPTURE WEIGHT = WT TVCL = THETA2 CL  ETA(1)\n\nIn this example, the names of the captured data items will be WEIGHT,TVCL,CL,ETA_1.\nUsers can use the capture type to declare variables in $MAIN and $TABLE. capture types are really doubles, but using that type will signal mrgsolve to automatically capture that value. For example:\n\n$PARAM VC = 300\n\n$CMT CENT\n\n$TABLE\ncapture DV = (CENT/VC);\n\nSince we used type capture for DV, DV will show up as a column in the simulated data.\nAnnotated example:\n\n$MAIN\ndouble CLi = TVCL*exp(ECL);\n\n$TABLE\ndouble DV = (CENT/VC)*exp(PROP);\n\n$CAPTURE @annotated\nCLi : Individual clearance (L/hr)\nDV  : Plasma concentration (mcg/ml)\n\nUse the @etas option to specify an expression that evaluates to integers which identify the ETA number(s) to capture. For example\n\n$OMEGA 0.1 0.2 0.3\n\n$CAPTURE @etas 1:LAST\nCL DV\n\nWill capture all three ETAs into the simulation outputs. NONMEM-style names will be used (e.g. ETA1). This is in contrast to the names that are generated when ETA(1) is captured; in this case, the parens are removed and replaced with _ so the output name is ETA_1. mrgsolve will provide LAST (and last) which will evaluate to the maximum number of ETAs in the problem (in this case, 3). You can write any valid expression in @etas. When the expression is evaluated, it will be evaluated in the model environment created through the $ENV block (Section 2.2.27).\n\n\n\n\n\n\nTip\n\n\n\nIn addition to listing model variables for otput in the $CAPTURE block, users can “dynamically” capture model variables through the capture argument to mread(). These may be model parameters (listed in $PARAM) or user-defined model variables.\nTo get a listing of available user-defined variables, you can use\n\nmod <- house()\nas.list(mod)$cpp_variables\n\n\n\n\n\n2.2.17 $OMEGA  \nSyntax: text\nMultiple allowed: yes\nOptions: @annotated, @block, @correlation, @labels, @name, @object, @as_object\nSee ?modMATRIX for more details about options for this block.\nUse this block to enter variance/covariance matrices for subject-level random effects drawn from multivariate normal distribution. All random effects are assumed to have mean of 0. Off diagonal elements for block matrices are assumed to be correlation coefficients if the @correlation option is used (see below).\nBy default, a diagonal matrix is assumed. So:\n\n$OMEGA\n1 2 3\n\nwill generate a 3x3 omega matrix.\nA block matrix may be entered by using block = TRUE. So:\n\n$OMEGA @block\n0.1 0.02 0.3\n\nwill generate a 2x2 matrix with covariance 0.02.\nA 2x2 matrix where the off-diagonal element is a correlation, not a covariance can be specified like this:\n\n$OMEGA @correlation\n0.1 0.67 0.3\n\nHere, the correlation is 0.67. mrgsolve will calculate the covariances and substitute these values. The matrix will be stored and used with these covariances, not the correlation.\nA name can be assigned to each matrix:\n\n$OMEGA @name PK @block\n0.2 0.02 0.3\n\n$OMEGA @name PD\n0.1 0.2 0.3 0.5\n\nto distinguish between multiple $OMEGA blocks and to facilitate updating later. The model in the preceding example will have two $OMEGA matrices: 2x2 and 4x4.\nLabels can be assigned which function as aliases for the different ETAs\n\n$OMEGA @block @labels ETA_CL ETA_V\n0.1 0.05 0.2\n\nThe number of labels should match the number of rows (or columns) in the matrix.\nAnnotated example (diagonal matrix):\n\n$OMEGA @annotated\nECL: 0.09 : ETA on clearance\nEVC: 0.19 : ETA on volume\nEKA: 0.45 : ETA on absorption rate constant\n\nAnnotated example (block matrix):\n\n$OMEGA @annotated @block\nECL: 0.09 : ETA on clearance\nEVC: 0.001 0.19 : ETA on volume\nEKA: 0.001 0.001 0.45 : ETA on absorption rate constant\n\nThe @object and @as_object options should name or return a square numeric matrix. If rownames are included in the matrix, then they will be used to form labels for the realized ETAs. For example, we can initialize a very large $OMEGA matrix with\n\n$OMEGA @as_object\nn <- 20\nlbl <- paste0(\"ETA_\", LETTERS[1:n])\nmatrix(0, 20, 20, dimnames = list(lbl, lbl))\n\nNote: this only initializes the matrix; you will (likely) need to update it with meaningful values after the model is loaded (Chapter 5).\n\n\n2.2.18 $SIGMA  \nSyntax: text\nMultiple allowed: yes\nOptions: @annotated, @block, @correlation, @labels, @name, @object, @as_object\nSee ?modMATRIX for more details about options for this block.\nUse this block to enter variance/covariance matrices for within-subject random effects drawn from multivariate normal distribution. All random effects are assumed to have mean of 0. Off diagonal elements for block matrices are assumed to be correlation coefficients if the @correlation option is used (see below).\nThe @object and @as_object options should name or return a square numeric matrix. If rownames are included in the matrix, then they will be used to form labels for the realized EPS values.\nThe $SIGMA block functions like the $OMEGA block. See $OMEGA for details.\n\n\n2.2.19 $SET\nSyntax: R\nMultiple allowed: no\nUse this code block to set different options for the simulation. Use a name = value format, where value is evaluated by the R interpreter.\nMost of the options that can be entered in $SET are passed to update.\nFor example:\n\n[ SET ] end = 240, delta = 0.5, req = \"RESP\"\n\nHere, we set the simulation end time to 240, set the time difference between two adjacent time points to 0.25 time units, and request only the RESP compartment in the simulated output.\n\n\n2.2.20 $GLOBAL\nSyntax: C++\nMultiple allowed: no\nThe $GLOBAL block is for writing C++ code that is outside of $MAIN, $ODE, and $TABLE.\nThere are no artificial limit on what sort of C++ code can go in $GLOBAL.\nHowever there are two more-common uses:\n\nWrite #define preprocessor statements\nDefine global variables, usually variables other than double, bool, int (see Section 2.5)\n\nPreprocessor directives Preprocessor #define directives are direct substitutions that the C++ preprocessor makes prior to compiling your code.\nFor example:\n\n[ GLOBAL ]\n#define CP (CENT/VC)\n\nWhen this preprocessor directive is included, everywhere the preprocessor finds a CP token it will substitute (CENT/VC). Both CENT and VC must be defined and the ratio of CENT to VC will be calculated depending on whatever the current values are. Notice that we included parentheses around (CENT/VC).\nThis makes sure the ratio between the two is taken first, before any other operations involving CP.\nDeclaring global variables Sometimes, you may wish to use global variables and have more control over how they get declared.\n\n$GLOBAL\nbool cure = false;\n\nWith this construct, the boolean variable cure is declared and defined right as the model is compiled.\nDeclare in bulk\nIf you have a large number of variables to declare, you can do that in bulk in $GLOBAL. For example, we know we will need a long list of double precision variable for covariate modeling, we can declare them all at once like this:\n\n[ global ] \ndouble TVCL, TVV2, TVQ = 0, TVV3 = 0;\n\n[ main ] \n\nTVCL = THETA1 * pow(WT / 70.0, 0.75);\nTVV2 = THETA2 * WT / 70.0;\nTVQ  = THETA3 * pow(WT / 70.0, 0.75);\nTVV3 = THETA4 * WT / 70.0;\n\nThis isn’t a terribly long list, but let’s pretend it is to illustrate how to do this. You can also declare int, bool and other types like this. I’ve initialized the last two (TVVQ and TVV3) to illustrate how to do this. It’s good practice to do that but not necessary as long as everything gets initialized to something before they are used.\n\n\n2.2.21 $PKMODEL\nSyntax: R\nMultiple allowed: no\nThis code block implements a one- or two-compartment PK model where the system is calculated by algebraic equations, not ODEs. mrgsolve handles the calculations and an error is generated if both $PKMODEL and $ODE blocks are included in the same model specification file.\nThis is an options-only block. The user must specify the number of compartments (1 or 2) to use in the model as well as whether or not to include a depot dosing compartment. See ?PKMODEL for more details about this block, including specific requirements for symbols that must be defined in the model specification file.\nThe $CMT or $INIT block must also be included with an appropriate number of compartments. Compartment names, however, may be determined by the user.\nExample:\n\n[ CMT ] GUT CENT PERIPH\n\n[ PKMODEL ] ncmt=2, depot=TRUE\n\nAs of version 0.8.2, we can alternatively specify the compartments right in the $PKMODEL block:\n\n$PKMODEL cmt=\"GUT CENT PERIPH\", depot = TRUE\n\nSpecifying three compartments with depot=TRUE implies ncmt=2. Notice that a separate $CMT block is not appropriate when cmt is specified in $PKMODEL.\n\n\n2.2.22 $PLUGIN  \nSyntax: text\nMultiple allowed: no\nPlugins are a way to add extensions to your mrgsolve model. Plugins can either link your model to external libraries (like boost or Rcpp) or they can open up access to additional functionality provided by mrgsolve itself.\nPlugins are listed and discussed in more detail in Chapter 9.\nUsage\nTo invoke a plugin, list the plugin name in the code block. For requesting Rcpp headers in your model, call\n\n$PLUGIN Rcpp\n\nAvailable plugins\nThe following plugins make additional mrgsolve-specific functionality available\n\nmrgx: extra C++ functions (see below)\ntad: track time after dose in your model\nN_CMT: get the number of a compartment\n\nThe following plugins give you a different model specification experience\n\nautodec: mrgsolve will find assignments in your model and automatically declare them as doubles\nnm-vars: a NONMEM look and feel for compartmental models; use F1, A(1) and DADT(1) rather than F_GUT, GUT and dxdt_GUT\n\nThe following plugin lets you customize how your model is compiled\n\nCXX11: compile your model with C++11 standard; this adds the compiler flag -std=c++11\n\nThe following plugins will let you link to external libraries\n\nRcpp: include Rcpp headers int your model\nBH: include boost headers in your model\nRcppArmadillo: include Armadillo headers in your model\n\nNote that Rcpp, RcppArmadillo and BH only allow you to link to those headers. To take advantage of that, you will need to know how to use Rcpp, boost etc. For the BH plugin, no headers are included for you; you must include the proper headers you want to use in $GLOBAL.\nmrgx This is a general collection of functions that we made available.\nFunctions provided by mrgx:\n\nT get<T>(std::string <pkgname>, std::string <objectname>)\n\nThis gets an object of any Rcpp-representable type (T) from any package\n\nT get<T>(std::string <objectname)\n\nThis gets an object of any Rcpp-representable type (T) from .GlobalEnv\n\nT get<T>(std::string <objectname>, databox& self)\n\nThis gets an object of any Rcpp-representable type (T) from $ENV\n\ndouble rnorm(double mean, double sd, double min, double max)\n\nSimulate one variate from a normal distribution that is between min and max\n\ndouble rlognorm(double mean, double sd, double min, double max)\n\nSame as mrgx::rnorm, but the simulated value is passed to exp after simulating\n\nRcpp::Function mt_fun()\n\nReturns mrgsolve::mt_fun; this is usually used when declaring a R function in $GLOBAL\nExample: Rcpp::Function print = mrgx::mt_fun();\n\n\nIMPORTANT All of these functions are in the mrgx namespace. So, in order to call these functions you must include mrgx:: namespace identifier to the front of the function name. For example, don’t use rnorm(50,20,40,140); use mrgx::rnorm(50,20,40,140).\n\n2.2.22.1 Some examples\nGet a numeric vector from $ENV\n\n[ PLUGIN ] Rcpp mrgx\n\n[ ENV ]\nx <- c(1,2,3,4,5)\n\n[ GLOBAL ]\nRcpp::NumericVector x;\n\n[ PREAMBLE ]\nx = mrgx::get<Rcpp::NumericVector>(\"x\", self);\n\nGet the print function from package:base\n\n$PLUGIN Rcpp mrgx\n\n$GLOBAL\nRcpp::Function print = mrgx::mt_fun();\n\n$PREAMBLE\nprint = mrgx::get<Rcpp::Function>(\"base\", \"print\");\n\n$MAIN\nprint(self.rown);\n\nNote that we declare the print in $GLOBAL and use the mt_fun() place holder.\nSimulate truncated normal variables This simulates a weight that has mean 80, standard deviation 20 and is greater than 40 and less than 140.\n\n$PLUGIN Rcpp mrgx\n\n$MAIN\nif(NEWIND <=1) {\n  double WT = mrgx::rnorm(80,20,40,140);\n}\n\nSee also: Section 2.2.14.\n\n\n\n2.2.23 $THETA  \nSyntax: text\nMultiple allowed: yes\nOptions: @annotated, @name, @object, @as_object\nUse this code block as an efficient way to add to the parameter list where names are determined by a prefix and a number. By default, the prefix is THETA and the number sequentially numbers the input values.\nFor example:\n\n[ THETA ]\n0.1 0.2 0.3\n\nis equivalent to\n\n$PARAM THETA1 = 0.1, THETA2 = 0.2, THETA3 = 0.3\n\nAnnotated example:\n\n$THETA @annotated\n0.1 : Typical value of clearance (L/hr)\n0.2 : Typical value of volume (L)\n0.3 : Typical value of ka (1/hr)\n\nTo change the prefix, use @name option\n\n$THETA @name theta\n0.1 0.2 0.3\n\nwould be equivalent to\n\n[ PARAM ] theta1 = 0.1, theta2 = 0.2, theta3 = 0.3\n\nThe @object and @as_object options should name or return an unnamed vector of parameter values (names are ignored).\nSee also: Section 2.2.4.\n\n\n2.2.24 $NMXML  \nSyntax: R\nMultiple allowed: yes\nThe $NMXML block lets you read and incorporate results from a NONMEM run into your mrgsolve model. For example\n\n$NMXML \nrun = 1001\nproject = \"../model/nonmem\"\nroot = \"cppfile\"\n\nFrom the NONMEM run, THETA will be imported into your parameter list (see Section 2.2.4 and Section 1.1), OMEGA will be captured as an $OMEGA block (Section 2.2.17) and SIGMA will be captured as a $SIGMA block (Section 2.2.18). Users may optionally omit any one of these from being imported.\n$NMXML contains a project argument and a run argument. By default, the estimates are read from from the file project/run/run.xml. That is, it is assumed that there is a directory named run that is inside the project directory where $NMXML will find run.xml. Your NONMEM run directories may not be organized in a way that is compatible with this default. In that case, you will need to provide the file argument, which should be the path to the run.xml file, either as a full path or as a path relative to the current working directory.\nOnce the model object is obtained, the path to the xml file that formed the source for imported parameters can be retrieved by coercing the model object to list and looking for nm_import:\n\nmod <- modlib(\"1005\", compile = FALSE)\n\nas.list(mod)$nm_import\n\nFor help on the arguments / options for $NMXML, please see the ?nmxml help topic in your R session after loading the mrgsolve package.\nAn example\nThere is a NONMEM run embedded in the mrgsolve package\n\npath <- file.path(path.package(\"mrgsolve\"),\"nonmem\")\nlist.files(path, recursive=TRUE)\n\n.  [1] \"1005/1005.cat\"    \"1005/1005.coi\"    \"1005/1005.cor\"    \"1005/1005.cov\"   \n.  [5] \"1005/1005.cpu\"    \"1005/1005.ctl\"    \"1005/1005.ext\"    \"1005/1005.grd\"   \n.  [9] \"1005/1005.lst\"    \"1005/1005.phi\"    \"1005/1005.shk\"    \"1005/1005.shm\"   \n. [13] \"1005/1005.tab\"    \"1005/1005.xml\"    \"1005/1005par.tab\" \"1005/INTER\"      \n. [17] \"2005/2005.ext\"\n\n\nWe can create a mrgsolve control stream that will import THETA, OMEGA and SIGMA from that run using the $NMXML code block.\n\n// inline/nmxml-1.cpp\n \n$NMXML\nrun = 1005\nproject = path\nroot = \"cppfile\"\n\nolabels = c(\"ECL\", \"EVC\", \"EKA\")\nslabels = c(\"PROP\", \"ADD\")\n\n$MAIN\ndouble CL = THETA1*exp(ECL);\ndouble V2 = THETA2*exp(EVC);\ndouble KA = THETA3*exp(EKA);\ndouble Q = THETA4;\ndouble V3 = THETA5;\n\n$PKMODEL ncmt=2, depot=TRUE\n\n$CMT GUT CENT PERIPH\n\n$TABLE\ndouble CP = (CENT/V2)*(1+PROP) + ADD/5;\n\n$CAPTURE CP\n\n$SET delta=4, end=96\n\nNOTE: in order to use this code, we need to install the xml2 package.\n\nmod <- mread(\"inline/nmxml-1.cpp\", compile = FALSE)\n\nmod\n\n. \n. \n. ---------------  source: nmxml-1.cpp  ---------------\n. \n.   project: /Users/kyleb/git...-guide/inline\n.   shared object: nmxml-1.cpp-so-d1613988829 <not loaded>\n. \n.   time:          start: 0 end: 96 delta: 4\n.                  add: <none>\n. \n.   compartments:  GUT CENT PERIPH [3]\n.   parameters:    THETA1 THETA2 THETA3 THETA4 THETA5\n.                  THETA6 THETA7 [7]\n.   captures:      CP [1]\n.   omega:         3x3 \n.   sigma:         2x2 \n. \n.   solver:        atol: 1e-08 rtol: 1e-08 maxsteps: 20k\n. ------------------------------------------------------\n\nparam(mod)\n\n. \n.  Model parameters (N=7):\n.  name   value  . name   value\n.  THETA1 9.51   | THETA5 113  \n.  THETA2 22.8   | THETA6 1.02 \n.  THETA3 0.0714 | THETA7 1.19 \n.  THETA4 3.47   | .      .\n\nrevar(mod)\n\n. $omega\n. $...\n.              [,1]        [,2]        [,3]\n. ECL:   0.21387884  0.12077020 -0.01162777\n. EVC:   0.12077020  0.09451047 -0.03720637\n. EKA:  -0.01162777 -0.03720637  0.04656315\n. \n. \n. $sigma\n. $...\n.              [,1]      [,2]\n. PROP:  0.04917071 0.0000000\n. ADD:   0.00000000 0.2017688\n\n\nroot argument: please use the root = \"cppfile\" argument going forward.\nAs of mrgsolve 0.11.0, we added an argument called root to $NMXML that tells mrgsolve the location where it should read the xml file from. The default behavior is the \"working\" directory. When this is the case, mrgsolve assumes that the the xml file can be found relative to the “working” directory. The only other value that root can take is \"cppfile\". When root = \"cppfile\", then mrgsolve will look for the xml file in a directory that is relative to where the model source code file is located. Please take a look at Section 2.2.25 for more discussion and examples.\nStarting with version 1.0.8, when the NONMEM run is found using the run + project arguments, you can pass run = \"@cppstem\" and mrgsolve will look for the NONMEM run number that matches the stem of the current mrgsolve file. For example, if you are coding a model to match NONMEM run 101.ctl, then call your mrgsolve model file 101.cpp or 101.mod; just match the file stem. Then write\n\n\n\n101.cpp\n\n$NMXML \nrun = \"@cppstem\"\nproject = <nonmem-run-directory>\n\n\nmrgsolve will check the stem of the mrgsolve model file and look for the NONMEM .xml file in\n\n<nonmem-run-directory>/101/101.xml\n\nPlease see the ?nmxml help topic for more information on arguments that can be passed to $NMXML.\nSee also: Section 2.2.25.\n\n\n2.2.25 $NMEXT  \nSyntax: R\nMultiple allowed: yes\nLike $NMXML, $NMEXT allows the import of $THETA, $OMEGA, and $SIGMA from your NONMEM run into your mrgsolve model, but the estimates are read from the .ext file output. $NMEXT is able to import the NONMEM estimates much faster than $NMXML when loading from sampling based methods (mainly METHOD=BAYES).\nWe can load the same mode as the $NMXML example above with the following code:\n\n// inline/nmext-1.cpp\n \n$NMEXT\nrun = 1005\nproject = file.path(path.package(\"mrgsolve\"),\"nonmem\")\nroot = \"cppfile\"\n\nolabels = c(\"ECL\", \"EVC\", \"EKA\")\nslabels = c(\"PROP\", \"ADD\")\n\n$MAIN\ndouble CL = THETA1*exp(ECL);\ndouble V2 = THETA2*exp(EVC);\ndouble KA = THETA3*exp(EKA);\ndouble Q = THETA4;\ndouble V3 = THETA5;\n\n$PKMODEL ncmt=2, depot=TRUE\n\n$CMT GUT CENT PERIPH\n\n$TABLE\ndouble CP = (CENT/V2)*(1+PROP) + ADD/5;\n\n$CAPTURE CP\n\n$SET delta = 4, end = 96\n\n\nmod <- mread(\"inline/nmext-1.cpp\", quiet=TRUE)\n\nparam(mod)\n\n. \n.  Model parameters (N=7):\n.  name   value  . name   value\n.  THETA1 9.51   | THETA5 113  \n.  THETA2 22.8   | THETA6 1.02 \n.  THETA3 0.0714 | THETA7 1.19 \n.  THETA4 3.47   | .      .\n\n\nOnce the model object is obtained, the path to the ext file that formed the source for imported parameters can be retrieved by coercing the model object to list and looking for nm_import. See the $NMXML topic in Section 2.2.24 for an example of equivalent functionality.\nIMPORTANT: while $NMEXT works very similarly to $NMXML, there is one key difference between the two: when using $NMEXT, you will always get one $OMEGA matrix and one $SIGMA matrix, regardless of the block structure used in the NONMEM control stream. When using $NMXML, you get the same block structure in the mrgsolve model as the NONMEM model. For example: in the NONMEM control stream, $OMEGA is one 2x2 matrix and one 3x3 matrix. Importing those estimates with $NMEXT will give you one 5x5 matrix, while importing the estimates with $NMXML will give you a list of one 2x2 and one 3x3 matrix.\nroot argument: please use the root = \"cppfile\" argument going forward.\nAs of mrgsolve 0.11.0, we added an argument called root to $NMEXT that tells mrgsolve the location where it should read the ext file from. The default behavior is the \"working\" directory. When this is the case, mrgsolve assumes that the the ext file can be found relative to the “working” directory. The only other value that root can take is \"cppfile\". When root = \"cppfile\", then mrgsolve will look for the ext file in a directory that is relative to where the model source code file is located.\nWe recommend that users start using the root argument and set it to “cppfile”. This will eventually become the default. For example:\n\n$NMEXT\nrun = 1005\nproject = \"../../model/pk\"\nroot = \"cppfile\"\n\nThis tells mrgsolve to find the nonmem run back two directories (../../) and then into model --> pk --> 1005 relative to where the mrgsolve model file is located. This is in contrast to the previous expected behavior that the path should be relative to the current working directory.\nWe also note here that when users pass an absolute path, the relative path doesn’t matter at all. Users are free to use pathing tools to generate the absolute path to the project. For example, the here::here() function can be used like this\n\n$NMEXT\nrun = 1005\nproject = here::here(\"model/pk\")\n\nWhen used in the proper context, here() will generate an absolute path from your projects root directory to the nonmem project directory. Please refer to the here::here() documentation for proper use of this function.\nStarting with version 1.0.8, when the NONMEM run is found using the run + project arguments, you can pass run = \"@cppstem\" and mrgsolve will look for the NONMEM run number that matches the stem of the current mrgsolve file. See details and example in Section 2.2.24.\nSee the ?nmext R help topic for arguments that can be passed to $NMEXT block. Notably, the user can select the function to read in the ext file.By default, mrgsolve will try to load data.table and use the fread function. If data.table can’t be loaded, then mrgsolve will use utils::read.table.\nSee also: Section 2.2.24.\n\n\n2.2.26 $INCLUDE  \nSyntax: text\nMultiple allowed: no\nTo include your own header file(s) in a model use $INCLUDE\n\n$INCLUDE\nmystuff.h\notherstuff.h\n\nor\n\n$INCLUDE\nmystuff.h,  otherstuff.h\n\nmrgsolve will insert proper #include preprocessor directives into the C++ code that gets compiled.\nRequirements\n\nAll header files listed in $INCLUDE are assumed (expected) to be under the project directory; don’t use $INCLUDE for header files that are in any other location\nAn error is generated if the header file does not exist\nAn error is generated if any quotation marks are found in the file name (don’t use quotes around the file name; mrgsolve will take care of that)\nA warning is issued if the header file does not end in .h\nWhen the header file is changed (MD5 checksum changes), the model will be forced to be rebuilt (recompiled) when mread() or mcode() (but not mread_cache() or mcode_cache()) is called; this feature is only available for header files listed in $INCLUDE (see below)\nDo not use $INCLUDE to include Rcpp, boost, RcppArmadillo or RcppEigen headers; use the appropriate $PLUGIN instead\n\nFor applications that don’t fit into the requirements listed above, users can always include header files in the model in $GLOBAL like this:\n\n$GLOBAL\n#include \"/Users/me/libs/mystuff.h\"\n\nBut be careful when doing this: if there are changes to mystuff.h but not to any other part of the model specification, the model may not be fully compiled when calling mread. In this case, always use preclean=TRUE argument to mread to force the model to be built when calling mread.\n\n\n2.2.27 $ENV  \nSyntax: R\nMultiple allowed: no\nThis block is all R code (just as you would code in a stand-alone R script. The code is parsed and evaluated into a new environment when the model is compiled.\nFor example:\n\n$ENV\n\nSigma <- cmat(1,0.6,2)\n\nmu <- c(2,4)\n\ncama <- function(mod) {\n  mod %>%\n    ev(amt=100, ii=12, addl=10) %>% \n    mrgsim(obsonly=TRUE,end=120)\n}\n\nObjects inside $ENV can be utilized in different C++ functions (see Section 2.2.22) or other parts of the simulation process.\nObjects inside $ENV will also be made available when parsing different parts of the model specification file. For example, we can initialize an $OMEGA block with the Sigma object in the $ENV block example above:\n\n$OMEGA @object Sigma\n\nAnother example is providing constants or functions to simplify code in the $PARAM block\n\n$ENV\nrescale <- 1/1000 \n\nconvert <- function(x) x * 5 / 166.2\n\n$PARAM\np = 500 * rescale\n\nq  = convert(2.51)\n\nYou can also make your model specification file depend on an R package; for example, if you want to use the here package to render a path to your NONMEM model\n\n$ENV\nif(!requireNamespace(\"here\")) {\n  stop(\"the `here` package is required to load this model.\")  \n}\n\n$NMXML\nrun = 101\nproject = here::here(\"model/nonmem\")\n\nYou can access the model environment using the env_get() function:\n\nenv_get(mod)\n\nor directly in the envir slot\n\nmod@envir\n\nSee also env_ls() to list the names of variables in the model environment, env_update() to change the values of objects in the model environment, or env_eval to re-evaluate the model environment code."
  },
  {
    "objectID": "specification.html#sec-variables-macros",
    "href": "specification.html#sec-variables-macros",
    "title": "2  Model specification",
    "section": "2.3 Variables and Macros",
    "text": "2.3 Variables and Macros\nThis section describes some macros and internal variables that can be used in model specification files. In the following section, we adopt the convention that CMT stands for a compartment in the model.\nIMPORTANT NOTE:\nIt should be clear from the usage examples which variables can be set by the user and which are to be read or checked. All internal variables are pre-defined and pre-initialized by mrgsolve. The user should never try to declare an internal variable; this will always result in an compile-time error.\n\n2.3.1 ID\nThe current subject identifier. ID is an alias for self.id.\n\n\n2.3.2 TIME\nGives the time in the current data set record. This is usually only used in $MAIN or $TABLE. TIME is an alias for self.time. Contrast with SOLVERTIME.\n\n\n2.3.3 SOLVERTIME\nGives the time of the current timestep taken by the solver. This is can only be used in $ODE. Contrast with TIME.\nStarting with mrgsolve version 1.0.0, the variable T is provided as a synonym to SOLVERTIME inside $ODE when you invoke the nm-vars plugin (Section 9.2).\n\n\n2.3.4 T\nOnly provided when the nm-vars plugin is invoked; see SOLVERTIME.\n\n\n2.3.5 EVID\nEVID is an event id indicator. mrgsolve recognized the following event IDs:\n\n0 = an observation record\n1 = a bolus or infusion dose\n2 = other type event, with solver reset\n3 = system reset\n4 = system reset and dose\n8 = replace\n\nEVID is an alias for self.evid.\n\n\n2.3.6 CMT\nCMT is the current compartment number. In this case, CMT is used literally (not a stand-in for the name of a compartment). For example:\n\n$CMT GUT CENT PERIPH\n\n$MAIN\n\nif(CMT==2) {\n  // ....\n}\n\nIn the example, GUT, CENT and PERIPH are the amounts in the respective compartments and CMT refers to the value of CMT in the data record / data set.\nCMT is an alias for self.cmt.\n\n\n2.3.7 AMT\nAMT is the current value of dose amount.\nAMT is an alias for self.amt.\n\n\n2.3.8 NEWIND\nNEWIND is a new individual indicator, taking the following values:\n\n0 for the first event record of the data set\n1 for the first event record of a subsequent individual\n2 for subsequent event record for an individual\n\nFor example:\n\n[ GLOBAL ]\nint counter = 0;\n\n[ MAIN ]\nif(NEWIND <=1) {\n  counter  = 0;\n}\n\nNEWIND is an alias for self.newind.\n\n\n2.3.9 SS_ADVANCE\nThis is a bool data item (either true or false) which is always false unless mrgsolve is currently advancing the system to steady state (Chapter 8); then it will be true. This variable is only available in the $ODE (or $DES) block.\nUse this variable to modify the calculation of your model differential equations while the system is advancing to steady state. One use case is when you have an accumulation compartment to calculate AUC but you want to halt accumulation while the system is working toward steady state\n\n$ODE\ndxdt_CENT = -(CL/V) * CENT;\ndxdt_AUC = CENT/V;\nif(SS_ADVANCE) dxdt_AUC = 0;\n\n\n\n2.3.10 simeta()\nThe simeta() function can be used to re-simulate ETA values. For example,\n\n$MAIN\nsimeta();\n\nwill re-simulate all ETA(n).\n\n\n2.3.11 simeps()\nsimeps() works like simeta(), but all EPS(n) values are re-simulated rather than the ETA values.\n\n\n2.3.12 self  \nself is an object that gets passed to your model function that contains data items and functions that can be called. It is a struct (see the source code here). A partial list of members are documented in the following sections.\nself functions include\n\nself.tad()\nself.mtime()\nself.mevent()\nself.stop()\nself.stop_id()\nself.stop_id_cf()\n\nself data members include\n\nself.id (ID)\nself.amt (AMT)\nself.cmt (CMT)\nself.evid (EVID)\nself.time (TIME)\nself.newind (NEWIND)\nself.nid\nself.idn\nself.rown\nself.nrow\nself.envir (see note below)\n\nThis information is provided for transparency and is not exhaustive. We provide an interface to these data items through pre-processor directives with simpler names (e.g. EVID will translate to self.evid) and users are encouraged to use the simpler, API name.\n\n\n2.3.13 self.time\nThe current data set TIME.\n\n\n2.3.14 self.cmt\nThe current compartment number regardless of whether it was given as cmt or CMT in the data set. There is no alias for self.cmt.\nFor example:\n\n$TABLE\n\ndouble DV = CENT/VC + EPS(1);\n\nif(self.cmt==3) DV = RESPOSE + EPS(2);\n\n\n\n2.3.15 self.amt\nThe current amt value regardless of whether it was given as amt or AMT in the data set. There is no alias for self.amt.\n\n[ PREAMBLE ]\ndouble last_dose = 0;\n\n[ MAIN ]\n\nif(EVID==1) {\n  last_dose = self.amt;  \n}\n\n\n\n2.3.16 self.nid\nThe number of IDs in the data set.\n\n\n2.3.17 self.idn\nThe current ID number. Numbers start at 0 and increase by one to self.nid-1. So if you want to test for the last ID in the output data set, you would write:\n\n[ table ]\n\nif(self.idn == (self.nid-1)) {\n  // do something ....\n}\n\n\n\n2.3.18 self.nrow\nThe total number of rows in the output data set.\n\n\n2.3.19 self.rown\nThe current row number. Numbers start at 0 and increase by one to self.rown-1. So if you want to test for the last row in the output data set, you would write:\n\n[ table ]\n\nif(self.rown == (self.nrow-1)) {\n  // do something ....\n}\n\n\n\n2.3.20 self.envir\nThis item is a null pointer that can be cast to an Rcpp::Environment only when the Rcpp plugin is invoked (see Section 9.5).\nFor example\n\n[ plugin ] Rcpp mrgx\n  \n[ preamble ] \nRcpp::Environment env = mrgx::get_envir(self);\n\n\n\n2.3.21 self.tad()  \nThis is a function that calculates and returns the time after the most recent dose event record (any record with EVID equal to 1 or 4). self.tad() will return -1 when it is called before the first dose record within an individual (NEWIND <= 1).\nThis function should be called in $MAIN every time $MAIN is called.\nFor example:\n\n$MAIN\n\ndouble TAD = self.tad();\n\nDo not make this calculation depend on any test or condition; it must be called every time $MAIN is called in order to see every dose.\n\n\n2.3.22 self.mtime(<time>)  \nThis is a function that creates a modeled even time. The only argument is a numeric time in the future for the current individual that indicates when a discontinuity should be included in the simulation.\nWhen when self.mtime() is called, a new record is added to the current individual’s record set with EVID set to 2. This means that when the system advances to this record (this time), the differential equation solver will reset and restart, creating the discontinuity. The function returns the time of this event so the user can work with it in subsequent code.\nFor example,\n\n$PARAM change_point = 5.13;\n\n$MAIN\n\ndouble KA = 1.1;\n\ndouble mt1 = self.mtime(change_point);\n\nif(TIME >= mt1) KA = 2.1;  \n\n\n\n2.3.23 self.mevent(<time>, <evid>)\nRelated to self.mtime() (Section 2.3.22), except you can set a specific EVID for this intervention and you track the change time via EVID rather than the time. You’d use this if you want to anchor several events in the future and be sure you can distinguish between them. For example\n\n[ main ] \nself.mevent(change_point1, 33);\nself.mevent(change_point2, 34);\n\nNow, you can look for EVID==33 to know you have hit change_point1 or EVID==34 to indicate that you have hit change_point2. Notice that self.mevent() doesn’t return any value. You will know that you’ve hit the change time by checking EVID.\n\n\n2.3.24 self.stop()\nThis self function is available to be called from $PREAMBLE, $MAIN, and $TABLE. When this function is called, the entire problem is stopped upon processing the next simulation record.\nThis might be called when something really bad happened and you just want to stop the simulation with an error.\n\n\n2.3.25 self.stop_id()\nThis self function is available to be called from $PREAMBLE, $MAIN, and $TABLE. When this function is called, processing of the current individual is stopped and missing values (NA_real) are filled in for remaining compartment’ and capture outputs.\nThis might be called when some condition is reached in the current individual that indicates either that the rest of the outputs are inconsequential or there was a problem with this particular individual.\nSee also self.stop_id() and self.stop().\n\n\n2.3.26 self.stop_id_cf()\nThis self function is available to be called from $PREAMBLE, $MAIN, and $TABLE. When this function is called, processing of the current individual is stopped and current values are carried forward (cf) for the remaining output records for that individual.\nThis might be called when some condition is reached in the current individual that indicates either that the rest of the outputs are inconsequential or there was a problem with this particular individual.\nSee also self.stop_id_cf() and self.stop().\n\n\n2.3.27 THETA(n)\nTHETA(n) is ubiquitous in NONMEM control streams, representing estimated fixed effect parameters. mrgsolve does not attach any special meaning to THETA(n) but starting with version 1.0.0 it will translate THETA(n) to THETAn. This is useful when importing NONMEM estimates using $NMXML or $NMEXT, where THETAs are imported as parameters with names THETA1, THETA2, THETA3 and so on (see Section 2.2.24 and Section 2.2.25). THETA(n) is simply a NONMEM-oriented style for referring to THETAn.\n\n\n2.3.28 ETA(n)\nETA(n) is the value of the subject-level variate drawn from the model OMEGA matrix. ETA(1) through ETA(25) have default values of zero so they may be used in a model even if appropriate OMEGA matrices have not been provided.\nFor example:\n\n$OMEGA\n1 2 3\n\n$MAIN\ndouble CL = TVCL*exp(ETA(1));\ndouble VC = TVVC*exp(ETA(2));\ndouble KA = TVKA*exp(ETA(3));\n\nHere, we have a 3x3 OMEGA matrix. ETA(1), ETA(2), and ETA(3) will be populated with variates drawn from this matrix. ETA(4) through ETA(25) will be populated with zero.\n\n\n2.3.29 EPS(n)\nEPS(n) holds the current value of the observation-level random variates drawn from SIGMA. The basic setup is the same as detailed in ETA(n).\nExample:\n\n[ CMT ] CENT\n\n[ PARAM ] CL=1, VC=20\n\n[ SIGMA ] \n25 0.0025\n\n[ TABLE ]\ndouble DV = (CENT/VC)*(1+EPS(2)) + EPS(1);\n\n\n\n2.3.30 SIGMA(n)\nStarting with version 1.0.8, users have read-only access to on-diagonal elements of \\(\\Sigma\\) through the SIGMA() macro. For example\n\n$SIGMA 0.1 12\n\n$TABLE\ndouble STD = sqrt(SIGMA(1) + pow(F,2)*SIGMA(2));\n\n\n\n2.3.31 table(<name>)\nThis macro has been deprecated. Users should not use code like this:\n\n[ TABLE ]\ntable(CP) = CENT/VC;\n\nBut rather this:\n\n$TABLE \ndouble CP = CENT/VC;\n\n$CAPTURE CP\n\nSee: Section 2.2.12 and also Section 2.2.16.\n\n\n2.3.32 F_CMT  \nFor the CMT compartment, sets the bioavailability fraction for that compartment.\nExample:\n\n$MAIN\nF_CENT = 0.7;\n\n\n\n2.3.33 ALAG_CMT  \nFor the CMT compartment, sets the lag time for doses into that compartment.\nExample:\n\n$MAIN\nALAG_GUT = 0.25;\n\n\n\n2.3.34 R_CMT  \nFor the CMT compartment, sets the infusion rate for that compartment. The infusion rate is only set via R_CMT when rate in the data set or event object is set to -1.\nExample:\n\n$MAIN\nR_CENT = 100;\n\n\n\n2.3.35 Rn\nOnly available when the nm-vars plugin is invoked; see R_CMT.\n\n\n2.3.36 D_CMT  \nFor the CMT compartment, sets the infusion duration for that compartment.\nThe infusion duration is only set via D_CMT when rate in the data set or event object is set to -2.\nExample:\n\n$MAIN\nD_CENT = 2;\n\n\n\n2.3.37 NONMEM-like syntax\nThere is a NONMEM-like syntax that lets you write F1 rather than F_GUT, D2 rather than D_CENT as well as other variables that are commonly used in a NONMEM control stream. To make this syntax available, the nm-vars plugin must be invoked.\nSee Section 9.2 on the nm-vars plugin for details."
  },
  {
    "objectID": "specification.html#reserved-words",
    "href": "specification.html#reserved-words",
    "title": "2  Model specification",
    "section": "2.4 Reserved words",
    "text": "2.4 Reserved words\nReserved words cannot be used as names for parameters, compartments or other derived variables in the model. Note that some of these words are “reserved” for you to use in your data set.\n\nID\namt\ncmt\nii\nss\nevid\naddl\nrate\ntime\nSOLVERTIME\ntable\nETA\nEPS\nAMT\nCMT\nID\nTIME\nEVID\nsimeps\nself\nsimeta\nNEWIND\nDONE\nCFONSTOP\nDXDTZERO\nCFONSTOP\nINITSOLV\n_F\n_R\n_ALAG\nSETINIT\nreport\n_VARS_\nVARS\nSS_ADVANCE\nAMT\nCMT\nII\nSS\nADDL\nRATE\nTHETA\npred_CL\npred_VC\npred_V\npred_V2\npred_KA\npred_Q\npred_VP\npred_V3\ndouble\nint\nbool\ncapture\n\nOther reserved words depend on the compartment names in your model. For example, if you have a compartment called CENT in the model, then the the following will be reserved\n\nF_CENT\nR_CENT\nD_CENT \nALAG_CENT\nN_CENT"
  },
  {
    "objectID": "specification.html#sec-new-variables",
    "href": "specification.html#sec-new-variables",
    "title": "2  Model specification",
    "section": "2.5 Derive new variables",
    "text": "2.5 Derive new variables\nNew C++ variables may be derived in $GLOBAL, $PREAMBLE $MAIN, $ODE and $TABLE. Because these are C++ variables, the type of variable being used must be declared. For the vast majority of applications, the double type is used (double-precision numeric value).\n\n$MAIN\n\ndouble CLi = TVCL*exp(ETA(1));\n\nWe want CLi to be a numeric value, so we use double. To initialize a boolean variable (true / false), write\n\n$MAIN\nbool cure = false;\n\n\n2.5.1 Special handling for double, int, bool\nWhen variables of the type double, int, and bool are declared and initialized in $PREAMBLE, $MAIN, $ODE, $TABLE, mrgsolve will detect those declarations, and modify the code so that the variables are actually declared once in $GLOBAL not in $MAIN, $ODE, or $TABLE. This is done so that variables declared in one code block (e.g. $MAIN) can be read and modified in another code block (e.g. $TABLE).\nFor example, in the following code:\n\n$MAIN\ndouble CLi = TVCL*exp(ETA(1));\n\na double-precision numeric variable is created (CLi) in the $MAIN block. When mrgsolve parses the model file, this code gets translated to\n\n$GLOBAL\nnamespace {\n  double CLi;\n}\n\n$MAIN\nCLi = TVCL*exp(ETA(1));\n\nThat is, CLi is declared in $GLOBAL in an unnamed namespace so that variables like this are global variables within the model file only.\nThis way, we can still read the CLi variable in $TABLE:\n\n$MAIN\ndouble CLi = TVCL*exp(ETA(1));\ndouble VCi = TVVC*exp(ETA(2));\n\n$TABLE\ndouble KEi = CLi/VCi;\n\n$CAPTURE KEi\n\nTo declare a variable that is local to a particular code block:\n\n$MAIN\n\nlocaldouble CLi = TVCL*exp(ETA(1));\n\nThe localdouble type is still just a double-precision variable. The difference is that it is protected from this re-declaration process and the variable will be local to (in this case) the $MAIN block.\n\n\n2.5.2 Initializing and resetting\nmrgsolve takes a hands-off approach to variables created by the user; it will not initialize or reset variables from record to record or from individual to individual. Failing to properly initialize or reset user variables can have unintended consequences, especially when conditional logic is used.\nGenerally, a default value for all variables should be set prior to conditional assignment based on some test condition.\n\n\n2.5.3 Using other types globally\nAs we noted in the previous section, double, int, and bool are processed in a special way so that they are by default global to the file. Many times we want to work with other variable types in a global manner. Whenever you want a data structure to be accessible across functions (e.g. $MAIN, $TABLE, etc.) they should be declared in $GLOBAL, optionally in an unnamed namespace.\nFor example:\n\n[ GLOBAL ]\nstd::vector<double> myvec;\n\nor\n\n[ GLOBAL ]\nnamespace {\n  std::vector<double> myvec;\n}\n\nIn case that object needs some configuration prior to starting the problem, use $PREAMBLE to do that work\n\n[ GLOBAL ]\nstd::vector<double> myvec;\n\n[ PREAMBLE ] \nmyvec.assign(3,1);"
  },
  {
    "objectID": "specification.html#random-number-generation",
    "href": "specification.html#random-number-generation",
    "title": "2  Model specification",
    "section": "2.6 Random number generation",
    "text": "2.6 Random number generation\nUsers can simulate random numbers inside a model file using functions that are similar to the functions you’d normally use in R (e.g. rnorm() and runif()). This functionality is provided by Rcpp and therefore requires using the Rcpp plugin (see Chapter 9 and Section 9.5).\nRcpp provides these functions inside the R namespace so you will have to prefix the function call with R::.\nAs an example, to make a draw from Uniform (0,1)\n\n[ plugin ] Rcpp\n  \n[ error ] \ndouble draw = R::runif(0,1);\n\nNote that the 0 gets used as min and the 1 gets used as max;\nwe didn’t pass n here and draw is a single number (not a vector like you’d get from (runif(100, 0, 1) on your R console). So in general, these functions work like their R counterparts, but without the n argument.\nAnother example showing how to draw from binomial distribution with probability 0.5\n\n[ plugin ] Rcpp\n  \n[ error ] \ndouble draw = R::rbinom(1, 0.5);\n\nHere, the 1 is used as size (not n) and 0.5 is used as prob.\nOther helpful functions could be R::rnorm() or R::rlnorm() but you can call any of the r functions as well as the corresponding dpq functions through this R namespace.\nDocumentation, including functions to call and arguments can be found in the Rcpp API docs\nhttp://dirk.eddelbuettel.com/code/rcpp/html/namespaceR.html"
  },
  {
    "objectID": "specification.html#examples",
    "href": "specification.html#examples",
    "title": "2  Model specification",
    "section": "2.7 Examples",
    "text": "2.7 Examples\nThe following sections show example model specification. The intention is to show how the different blocks, macros and variables can work together to make a functional model. Some models are given purely for illustrative purpose and may not be particularly useful in application.\n\n2.7.1 Simple PK model\nNotes:\n\nBasic PK parameters are declared in $PARAM; every parameter needs to be assigned a value\nTwo compartments GUT and CENT are declared in $CMT; using $CMT assumes that both compartments start with 0 mass\nBecause we declared GUT and CENT as compartments, we write dxdt_ equations for both in $ODE\nIn $ODE, we refer to parameters (CL/VC/KA) and the amounts in each compartment at any particular time (GUT and CENT)\n$ODE should be C++ code; each line ends in ;\nWe derive a variable called CP in $TABLE that has type capture; mrgsolve will enter the CP name into the $CAPTURE block list\n\n\n$PARAM CL = 1, VC = 30, KA = 1.3\n\n$CMT GUT CENT\n\n$ODE\n\ndxdt_GUT = -KA*GUT;\ndxdt_CENT = KA*GUT - (CL/VC)*CENT;\n\n$TABLE\ncapture CP = CENT/VC;\n\nThis model can also be written without differential equations\n\n[ PARAM ] CL = 1, VC = 30, KA = 1.3\n\n[ PKMODEL ] cmt = \"CMT GUT CENT\", depot = TRUE\n\n$TABLE\ncapture CP = CENT/VC;\n\n\n\n2.7.2 PK/PD model\nNotes:\n\nWe use a preprocessor #define directive in $GLOBAL; everywhere in the model where a CP token is found, the expression (CENT/VC) … with parentheses … is inserted\nWe write the initial value for the RESP compartment in $MAIN as a function of two parameters KIN/KOUT\nA new variable - INH- is declared and used in $ODE\nSince CP is defined as CENT/VC, we can “capture” that name/value in $CAPTURE\nBoth $MAIN and $ODE are C++ code blocks; don’t forget to add the ; at the end of each statement\n\n\n$PARAM CL = 1, VC = 30, KA = 1.3\nKIN = 100, KOUT = 2, IC50 = 2\n\n$GLOBAL\n#define CP (CENT/VC)\n\n$CMT GUT CENT RESP\n\n$MAIN\nRESP_0 = KIN/KOUT;\n\n$ODE\n\ndouble INH = CP/(IC50+CP);\n\ndxdt_GUT = -KA*GUT;\ndxdt_CENT = KA*GUT - (CL/VC)*CENT;\ndxdt_RESP = KIN*(1-INH) - KOUT*RESP;\n\n$CAPTURE CP\n\n\n\n2.7.3 Population PK model with covariates and IOV\nNotes:\n\nUse $SET to set the simulation time grid from 0 to 240 by 0.1\nThere are two $OMEGA matrices; we name them IIV and IOV\nThe IIV “etas” are labeled as ECL/EVC/EKA; these are aliases to ETA(1)/ETA(2)/ETA(3). The IOV matrix is unlabeled; we must refer to ETA(4)/ETA(5) for this\nBecause ETA(1) and ETA(2) are labeled, we can “capture” them as ECL and EVC\nWe added zeros for both $OMEGA matrices; all the etas will be zero until we populate those matrices (Section 5.3)\n\n\n$PARAM TVCL = 1.3, TVVC=28, TVKA=0.6, WT=70, OCC=1\n\n$SET delta=0.1, end=240\n\n$CMT GUT CENT\n\n$MAIN\n\ndouble IOV = IOV1\nif(OCC==2) IOV = IOV2;\n\ndouble CLi = exp(log(TVCL) + 0.75*log(WT/70) + ECL + IOV);\ndouble VCi = exp(log(TVVC) + EVC);\ndouble KAi = exp(log(TVKA) + EKA);\n\n$OMEGA @name IIV @labels ECL EVC EKA\n0 0 0\n$OMEGA @name IOV @labels IOV1 IOV2\n0 0\n\n$SIGMA 0\n\n$ODE\ndxdt_GUT = -KAi*GUT;\ndxdt_CENT = KAi*GUT - (CLi/VCi)*CENT;\n\n$TABLE\ncapture CP = CENT/VCi;\n\n$CAPTURE IOV ECL EVC"
  },
  {
    "objectID": "datasets.html#sec-datasets",
    "href": "datasets.html#sec-datasets",
    "title": "3  Input data sets",
    "section": "3.1 Overview",
    "text": "3.1 Overview\nData sets are the primary mechanism for establishing the scope of your simulations in mrsolve, including individuals, interventions, observation times, and parameter values. For both data_set and idata_set (see below), you may include columns in the data sets that have the same names as the parameters in your model (Section 1.1, Section 2.2.4). mrgsolve can recognize these columns and update the parameter list as the simulation proceeds. This process is of key importance when planning and executing complex simulations and is further discussed in section Section 11.3."
  },
  {
    "objectID": "datasets.html#sec-data-set",
    "href": "datasets.html#sec-data-set",
    "title": "3  Input data sets",
    "section": "3.2 Event data sets (data)",
    "text": "3.2 Event data sets (data)\nEvent data sets are entered as data.frame, with one event per row. Events may be observations, doses, or other type events. In mrgsolve documentation, we refer to these data sets as data or data_set (after the function that is used to associate the data set with the model object prior to simulation).\nEvent data sets have several special column names that mrgsolve is always aware of:\n\nID the subject id. This id does not need to be unique in the data_set: mrgsolve detects an new individual when the current value of ID is different from the immediate preceding value of ID. However, we always recommend using unique ID.\ntime or TIME: states the time of the data record\nevid or EVID: the event id indicator. evid can take the values:\n\n0 = observation record\n1 = dosing event (bolus or infusion)\n2 = other type event, with solver stop and restart\n3 = system reset\n4 = reset and dose\n8 = replace the amount in the compartment with amt\n\namt or AMT: the dose amount (if evid==1)\ncmt or CMT: the dosing compartment number. This may also be a character value naming the compartment name. The compartment number must be consistent with the number of compartments in the model for dosing records (evid==1).\nFor observation records, a cmt value of 0 is acceptable. Use a negative compartment number with evid 2 to turn a compartment off.\n\nrate or RATE: if non-zero and evid=1 or evid=4, implements a zero-order infusion of duration F_CMT*amt/rate, where F_CMT is the bioavailability fraction for the dosing compartment. Use rate = -1 to model the infusion rate and rate = -2 to model the infusion duration, both in $MAIN (see Section 2.2.8, Section 2.3.32, Section 2.3.34, Section 2.3.36).\nii or II: inter-dose interval; ii=24 means daily dosing when the model time unit is hours\naddl or ADDL: additional doses; a non-zero value in addl requires non-zero ii on the same record\nss or SS steady state indicator; use 1 to implement steady-state dosing; 0 otherwise. mrgsolve also recognizes dosing records where ss=2. This allows combination of different steady state dosing regimens under linear kinetics (e.g. 10 mg QAM and 20 mg QPM daily to steady state).\n\nThe column names in the preceding list were written either as lower case form (e.g. amt) or upper case form (e.g. AMT). Either may be used, however the data set will be checked for consistency of usage. An error will be issued in case a mixture of lower and upper case names are found.\nIn addition to these special column names, mrgsolve will recognize columns in data_set that have the same name as items in the parameter list (see Section 2.2.4 and Section 1.1). When mrgsolve sees that the names match up, it will update the values of those matching names based on what it finds as it moves through the data set (see Section 11.3).\n\n3.2.1 Two types of data_set\nmrgsolve distinguishes between two types of data sets: data sets that have at least one observation record (evid=0) and data sets that have no records with evid=0.\n\nFull data sets have a mix of observations and dosing events (likely, but not required). When mrgsolve finds one record with evid=0, it assumes that ALL output observation times are to come from the data set. In this case the simulation output time grid discussed in Section 1.3 is ignored and only observations found in the data set appear in the simulated output. Use full data sets when you want a highly customized sampling schedule or you are working with a clinical data set.\nCondensed data sets have no records with evid=0. In this case, mrgsolve will fill the simulated output with observations at times specified by the output time grid (Section 1.3 and see Section 11.5 too). These are very convenient to use because there is less data assembly burden and output data sets can easily be created with very dense sampling scheme or highly customized sampling schemes with very little work. Use a condensed data set when you want a uniform set of sampling times for all subjects in the data set.\n\nExample of condensed data set\n\ndata(extran1, package = \"mrgsolve\")\nextran1\n\n.   ID  amt cmt time addl ii rate evid\n. 1  1 1000   1    0    3 24    0    1\n. 2  2 1000   2    0    0  0   20    1\n. 3  3 1000   1    0    0  0    0    1\n. 4  3  500   1   24    0  0    0    1\n. 5  3  500   1   48    0  0    0    1\n. 6  3 1000   1   72    0  0    0    1\n. 7  4 2000   2    0    2 48  100    1\n. 8  5 1000   1    0    0  0    0    1\n. 9  5 5000   1   24    0  0   60    1\n\n\nSee ?exdatasets in the R help system after loading mrgsolve.\nExample of full data set\n\ndata(exTheoph, package = \"mrgsolve\")\n\nhead(exTheoph)\n\n.   ID   WT Dose time  conc cmt  amt evid\n. 1  1 79.6 4.02 0.00  0.00   1 4.02    1\n. 2  1 79.6 4.02 0.25  2.84   0 0.00    0\n. 3  1 79.6 4.02 0.57  6.57   0 0.00    0\n. 4  1 79.6 4.02 1.12 10.50   0 0.00    0\n. 5  1 79.6 4.02 2.02  9.66   0 0.00    0\n. 6  1 79.6 4.02 3.82  8.58   0 0.00    0\n\n\nSee ?exdatasets in the R help system after loading mrgsolve.\nAugmenting observations in a clinical data set Occasionally, we want to simulate from a clinical data set (with observation records as actually observed in a population of patients) but we also want to augment those observations with a regular sequence of times (for example, to make a smooth profile on a plot). In that case, you can set obsaug  = TRUE when calling mrgsim.\nFor example:\n\nmod <- house()\n\nout <- \n  mod %>%\n    data_set(exTheoph, ID==1) %>%\n    carry.out(a.u.g) %>%\n    obsaug %>%\n    mrgsim(end = 24, delta = 1)\n\nout\n\n. Model:  housemodel \n. Dim:    36 x 8 \n. Time:   0 to 24.37 \n. ID:     1 \n.     ID time a.u.g    GUT  CENT  RESP      DV      CP\n. 1:   1 0.00     1 0.0000 0.000 50.00 0.00000 0.00000\n. 2:   1 0.00     0 4.0200 0.000 50.00 0.00000 0.00000\n. 3:   1 0.25     0 2.9781 1.035 49.95 0.04552 0.04552\n. 4:   1 0.57     0 2.0285 1.961 49.81 0.08624 0.08624\n. 5:   1 1.00     1 1.2108 2.729 49.61 0.12001 0.12001\n. 6:   1 1.12     0 1.0484 2.875 49.57 0.12643 0.12643\n. 7:   1 2.00     1 0.3647 3.422 49.34 0.15048 0.15048\n. 8:   1 2.02     0 0.3560 3.428 49.33 0.15072 0.15072\n\nout %>% select(time) %>% unlist() %>% unname()\n\n.  [1]  0.00  0.00  0.25  0.57  1.00  1.12  2.00  2.02  3.00  3.82  4.00  5.00\n. [13]  5.10  6.00  7.00  7.03  8.00  9.00  9.05 10.00 11.00 12.00 12.12 13.00\n. [25] 14.00 15.00 16.00 17.00 18.00 19.00 20.00 21.00 22.00 23.00 24.00 24.37\n\n\nobsaug requests that the data set be augmented with observations from the simulation time grid. We can optionally request an indicator called a.u.g to appear in the output that takes value of 1 for augmented observations and 0 for observations from the data set.\n\n\n3.2.2 Sorting requirements\nThe IDs in the data set can appear in any order. However, an error will be generated if time on any record is less that time on the previous record within any ID.\n\n\n3.2.3 Creating data sets\nThe expand.ev function is provided by mrgsolve to help in creating data sets of a certain style. But any R code that produces a valid data set is fine to use.\n\n\n3.2.4 Example\nTo create a data set of 3 people each receiving 250 mg every 8 hours for 12 total doses:\n\ndata <- expand.ev(ID=1:3, amt=250, ii=8, addl=11)\n\ndata\n\n.   ID time amt ii addl cmt evid\n. 1  1    0 250  8   11   1    1\n. 2  2    0 250  8   11   1    1\n. 3  3    0 250  8   11   1    1\n\n\nNotice that expand.ev assumes that time is 0 and cmt is 1. To dose as a 2-hour infusion into the second compartment use:\n\ndata <- expand.ev(ID=1:3, amt=250, rate=125, ii=8, addl=11, cmt=2)\n\ndata\n\n.   ID time amt rate ii addl cmt evid\n. 1  1    0 250  125  8   11   2    1\n. 2  2    0 250  125  8   11   2    1\n. 3  3    0 250  125  8   11   2    1\n\n\nUse data_set to pass the data into the problem.\nFor example:\n\nmod <- house()\n\nmod %>%\n  data_set(data) %>%\n  mrgsim(end=240) %>%\n  plot(CP~time|factor(ID))"
  },
  {
    "objectID": "datasets.html#sec-idata-set",
    "href": "datasets.html#sec-idata-set",
    "title": "3  Input data sets",
    "section": "3.3 Individual data sets (idata)",
    "text": "3.3 Individual data sets (idata)\nIndividual data sets carry individual-level data. This individual data is used in several different ways:\n\nIndividual-level parameters: Just prior to simulating any individual, mrgsolve checks the appropriate row in idata (if supplied) for any columns with parameter names. If parameter names are found, the parameter list is updated and that update remains in effect for the duration of that individual’s data records.\nIndividual- or group-level designs: Each individual or group of individual may be assigned a different sampling design. For example, individuals in arm 1 may need to be simulated for 4 weeks whereas individuals in arm 2 may need to be simulated for 8 weeks. idata may be used to identify one of several sampling designs for each individual or group of individuals.\nIndividual-level compartment initialization: if a model has a compartment called CMT and mrgsolve finds a column in idata called CMT_0, the value of CMT_0 will be used to initialize that compartment with, potentially a different value for each individual. Note that there are several other ways to initialize compartments detailed in Section 11.2.\n\nidata_set are entered as data.frame with one unique ID per row. In mrgsolve documentation, we refer to individual data sets idata or idata_set to distinguish them from event data sets (see Section 3.2).\nAn idata_set looks like this:\n\ndata(exidata)\n\nexidata\n\n.    ID    CL    VC     KA  KOUT  IC50 FOO\n. 1   1 1.050 47.80 0.8390 2.450 1.280   4\n. 2   2 0.730 30.10 0.0684 2.510 1.840   6\n. 3   3 2.820 23.80 0.1180 3.880 2.480   5\n. 4   4 0.552 26.30 0.4950 1.180 0.977   2\n. 5   5 0.483  4.36 0.1220 2.350 0.483  10\n. 6   6 3.620 39.80 0.1260 1.890 4.240   1\n. 7   7 0.395 12.10 0.0317 1.250 0.802   8\n. 8   8 1.440 31.20 0.0931 4.030 1.310   7\n. 9   9 2.570 18.20 0.0570 0.862 1.950   3\n. 10 10 2.000  6.51 0.1540 3.220 0.699   9\n\n\nHere we have an idata_set with 10 subjects, one subject per row. The ID column connects the data in each row to the data in a data_set, which also requires an ID column.\nThe ID column is the only required column name in idata_set and ID should always be a unique identifier for that row.\n\n3.3.1 Use case\nidata_set is usually helpful for implementing a batch of simulations when a data_set is not used. The batch may be as a sensitivity analysis or for population simulation. Usually, an events object is used with idata, but it is not required.\nUse the idata_set function to pass the data set into the problem.\nFor example:\n\nmod <- house()\n\nmod %>%\n  idata_set(exidata) %>%\n  ev(amt = 100) %>%\n  mrgsim() %>% \n  plot()\n\n\n\n\nBecause there were 10 subjects in the idata_set, we get 10 profiles in the output. Each “individual” or “unit” received the same 100 mg dose. We would use a data_set to assign different doses to different individuals."
  },
  {
    "objectID": "datasets.html#sec-numeric-only",
    "href": "datasets.html#sec-numeric-only",
    "title": "3  Input data sets",
    "section": "3.4 Numeric data only",
    "text": "3.4 Numeric data only\nThe data.frame holding the data_set or idata_set may have any type of data in its columns. However, only numeric data can actually get passed into the simulation engine. mrgsolve will automatically look for non-numeric columns and drop them from the data_set or idata_set with a warning."
  },
  {
    "objectID": "datasets.html#missing-values",
    "href": "datasets.html#missing-values",
    "title": "3  Input data sets",
    "section": "3.5 Missing values",
    "text": "3.5 Missing values\nIf missing values (NA) are found in columns which match parameter names, a warning will be issued and the user should expect NaN in the simulated output if these parameters factor into the advance of the system.\nStarting with version 1.0.8, missing values in the following columns of input data_sets will be silently converted to 0\n\nCMT\nAMT\nRATE\nEVID\nII\nADDL\nSS\n\nThe lower case versions of these names may also include NA and will get converted to 0\n\ncmt\namt\nrate\nevid\nii\naddl\nss\n\nidata_sets are not checked for missing values in these columns."
  },
  {
    "objectID": "datasets.html#sec-valid_data_set",
    "href": "datasets.html#sec-valid_data_set",
    "title": "3  Input data sets",
    "section": "3.6 Data set validation",
    "text": "3.6 Data set validation\nA the time of simulation, mrgsolve will validate the input data set, removing non-numeric columns, checking for missing values in parameter columns, checking compartment numbers, etc.\nUsers can pre-validate the data set so that this does not need to happen at run time.\n\ndata(exTheoph)\n\nhead(exTheoph)\n\n.   ID   WT Dose time  conc cmt  amt evid\n. 1  1 79.6 4.02 0.00  0.00   1 4.02    1\n. 2  1 79.6 4.02 0.25  2.84   0 0.00    0\n. 3  1 79.6 4.02 0.57  6.57   0 0.00    0\n. 4  1 79.6 4.02 1.12 10.50   0 0.00    0\n. 5  1 79.6 4.02 2.02  9.66   0 0.00    0\n. 6  1 79.6 4.02 3.82  8.58   0 0.00    0\n\nmod <- modlib(\"pk1\", compile = FALSE)\n\nvalid <- valid_data_set(exTheoph, mod)\n\nstr(valid)\n\n.  'valid_data_set' num [1:132, 1:9] 1 1 1 1 1 1 1 1 1 1 ...\n.  - attr(*, \"dimnames\")=List of 2\n.   ..$ : NULL\n.   ..$ : chr [1:9] \"ID\" \"WT\" \"Dose\" \"time\" ...\n\n\nThis can improve efficiency when performing a very large number of replicate simulations on the same data set, but is unlikely to provide a meaningful speed-up for a single simulation or a small number of simulations."
  },
  {
    "objectID": "datasets.html#sec-pred-data",
    "href": "datasets.html#sec-pred-data",
    "title": "3  Input data sets",
    "section": "3.7 Data sets for use with $PRED",
    "text": "3.7 Data sets for use with $PRED\nBecause there are no compartments involved, there are relaxed data set requirements for models that utilize $PRED.\n\ntime or TIME is not required as input; when this is not supplied, a time column will be included in output with value 0\nWhen time or TIME is supplied, it may be negative; but records must still be sorted by time or TIME\nIf supplied, cmt or CMT must be zero\nAn error is generated if rate or RATE is supplied\nAn error is generated if ss or SS is supplied"
  },
  {
    "objectID": "event.html#usage",
    "href": "event.html#usage",
    "title": "4  Event objects",
    "section": "4.1 Usage",
    "text": "4.1 Usage\nEvent objects are frequently used in a pipeline to simulate a dosing regimen. For example\n\nmod <- house(end = 72) \n\nmod %>% ev(amt = 100, ii = 24, addl = 1) %>% mrgsim() %>% plot(\"CP\")\n\n\n\n\nThis used the ev() constructor to make an event object for two 100 mg doses and this is passed into mrgsim() to implement this regimen.\nAlternatively, we can create a standalone object containing the event information\n\nregimen <- ev(amt = 100, ii = 24, addl = 1)\n\nand pass that into the simulation pipeline\n\nmod %>% ev(regimen) %>% mrgsim() %>% plot(\"CP\")\n\nIf you are not using the pipe syntax, the following would be equivalent calls\n\nmrgsim(mod, events = regimen) %>% plot(\"CP\")\n\nAnd there are mrgsim() variants that explicitly accept an event object\n\nmrgsim_e(mod, regimen) %>% plot(\"CP\")\n\nMore will be said about how to create and manipulate event objects in the following sections."
  },
  {
    "objectID": "event.html#construction",
    "href": "event.html#construction",
    "title": "4  Event objects",
    "section": "4.2 Construction",
    "text": "4.2 Construction\nA new event object can be created with the ev() constructor. For a single, 100 mg dose it would be\n\ne <- ev(amt = 100)\n\nWhen you print the object to the R console we see the 100 mg dose along with the following defaults\n\ntime set to 0\ncmt set to 1 (the first compartment)\nevid set to 1 (a bolus dose)\n\n\ne\n\n. Events:\n.   time amt cmt evid\n. 1    0 100   1    1\n\n\nOf course, we can override any of these defaults or add additional items as needed. For a single 100 mg dose infused over 2 hours in compartment 2 one hour after the simulation starts\n\ne <- ev(amt = 100, rate = 50, cmt = 2, time = 1)\n\nTo use this event object, we can pass it into mrgsim() under the events argument\n\nmod <- house(delta = 1, end = 24)\n\nmrgsim(mod, events = e)\n\n. Model:  housemodel \n. Dim:    26 x 7 \n. Time:   0 to 24 \n. ID:     1 \n.     ID time GUT  CENT  RESP    DV    CP\n. 1:   1    0   0  0.00 50.00 0.000 0.000\n. 2:   1    1   0  0.00 50.00 0.000 0.000\n. 3:   1    1   0  0.00 50.00 0.000 0.000\n. 4:   1    2   0 48.77 44.12 2.439 2.439\n. 5:   1    3   0 95.16 36.98 4.758 4.758\n. 6:   1    4   0 90.52 34.61 4.526 4.526\n. 7:   1    5   0 86.11 34.75 4.305 4.305\n. 8:   1    6   0 81.91 35.22 4.095 4.095\n\n\nEvent object inputs can be functions of previously defined inputs. For example\n\nev(amt = 100, rate = amt / 2)\n\n. Events:\n.   time amt rate cmt evid\n. 1    0 100   50   1    1\n\n\nSee the ?ev() help topic for more information on additional arguments when constructing event objects. Here, I’d like to specifically highlight a handful of options that can be helpful when constructing event objects.\nInfusion duration\nAbove, we created some infusion event objects by adding an infusion rate to the input. We can also indicate an infusion by adding an infusion time through the tinf argument\n\nev(amt = 100, tinf = 2)\n\n. Events:\n.   time amt rate cmt evid tinf\n. 1    0 100   50   1    1    2\n\n\nID\nWhile the primary use case for event objects are for single individuals, we can code a series of IDs into the object too\n\nev(amt = 100, ID = 1:3)\n\n. Events:\n.   ID time amt cmt evid\n. 1  1    0 100   1    1\n. 2  2    0 100   1    1\n. 3  3    0 100   1    1\n\n\nHere, we asked for 3 IDs in the object. Once this is turned into a simulation data set (see below), we’ll have a population data set from which to simulate.\nAdditional data items\nWe can also pass through arbitrary data columns through the event object. For example, we can pass through WT\n\nev(amt = 100, WT = 80)\n\n. Events:\n.   time amt cmt evid WT\n. 1    0 100   1    1 80"
  },
  {
    "objectID": "event.html#coerce-to-data-set",
    "href": "event.html#coerce-to-data-set",
    "title": "4  Event objects",
    "section": "4.3 Coerce to data set",
    "text": "4.3 Coerce to data set\nAs we noted, event objects are very similar to data sets and they are nothing but data sets under the hood. We can take the event objects we created above and coerce them to other objects.\nUsing as_data_set\n\nas_data_set(e)\n\n.   time amt rate cmt evid ID\n. 1    1 100   50   2    1  1\n\n\nThis will ensure that there is an ID column in the output and it will be suitable to use for simulation.\nUsing as.data.frame\n\nas.data.frame(e) %>% mutate(ID = 5)\n\n.   time amt rate cmt evid ID\n. 1    1 100   50   2    1  5\n\n\nUpper case names\nSee Section 4.8 for a constructor for an event object that renders with upper case names."
  },
  {
    "objectID": "event.html#extract-information",
    "href": "event.html#extract-information",
    "title": "4  Event objects",
    "section": "4.4 Extract information",
    "text": "4.4 Extract information\nThere is a $ operator for event objects\n\ne$amt\n\n. [1] 100"
  },
  {
    "objectID": "event.html#combining-event-objects",
    "href": "event.html#combining-event-objects",
    "title": "4  Event objects",
    "section": "4.5 Combining event objects",
    "text": "4.5 Combining event objects\n\n4.5.1 Concatenate\nTwo or more event objects can be concatenated using the c operator\n\ne1 <- ev(amt = 100)\ne2 <- ev(amt = 200, time = 24)\n\nc(e1, e2)\n\n. Events:\n.   time amt cmt evid\n. 1    0 100   1    1\n. 2   24 200   1    1\n\n\nThis essentially “rbinds” the rows of the individual event objects and sorts the rows by time.\nNOTE: the result of this manipulation is another event object.\n\n\n4.5.2 Sequence\nEvent objects can also be combined to happen in a sequence. In the previous example, we wanted the 200 mg to happen at 24 hours and we had to code that fact into time accordingly.\nBy specifying a dosing interval (ii) we can ask mrgsolve to do that automatically by calling the seq() method.\n\ne1 <- ev(amt = 100, ii = 24)\ne2 <- ev(amt = 200, ii = 24)\n\nseq(e1, e2)\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 24    0   1    1\n. 2   24 200 24    0   1    1\n\n\nThis was a trivial example to get a simple result. We can try something more complicated to make the point\n\ne3 <- ev(amt = 100, ii = 6,  addl = 28)\ne4 <- ev(amt = 200, ii = 12, addl = 124)\ne5 <- ev(amt = 400, ii = 24, addl = 3)\n\nseq(e3, e4, e5)\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100  6   28   1    1\n. 2  174 200 12  124   1    1\n. 3 1674 400 24    3   1    1\n\n\nNOTE: when mrgsolve puts event objects into a sequence, it starts the next segment of the regimen one dosing interval after the previous regimen finished. Going back to the simple example\n\nseq(e1, e2)\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 24    0   1    1\n. 2   24 200 24    0   1    1\n\n\ne1 was just a single dose at time 0. mrgsolve will have e2 start one dosing interval (24 hours) after the last (only) dose in e1. We can alter the amount of time between segments of the regimen by using the wait argument. For example, to push e2 out by an additional 24 hours we’d use\n\nseq(e1, wait = 24, e2)\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 24    0   1    1\n. 2   48 200 24    0   1    1\n\n\nWe can also use a negative value for wait to make the next dose happen sooner\n\nseq(e1, wait = -12, e2)\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 24    0   1    1\n. 2   12 200 24    0   1    1\n\n\nFinally, we should note that event objects can be used multiple times in a sequence\n\nseq(e1, e2, wait = 7*24, e2, e1)\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 24    0   1    1\n. 2   24 200 24    0   1    1\n. 3  216 200 24    0   1    1\n. 4  240 100 24    0   1    1\n\n\n\n\n4.5.3 repeat\nLike the seq() method for event objects, ev_repeat will put an event object into a sequence n times\n\nev_repeat(e1, n = 3)\n\n.   time amt ii cmt evid addl\n. 1    0 100 24   1    1    0\n. 2   24 100 24   1    1    0\n. 3   48 100 24   1    1    0\n\n\nBy default, this function returns a regular data frame. To return an event object instead call\n\nev_repeat(e1, n = 3, as.ev = TRUE)\n\nYou can put a waiting period too. To illustrate this, let’s compose a more complicated regimen and repeat that\n\ne1 <- ev(amt = 500, ii = 24)\ne2 <- ev(amt = 250, ii = 24, addl = 5)\ne3 <- ev_seq(e1, e2)\n\ne3 %>% realize_addl()\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 500  0    0   1    1\n. 2   24 250  0    0   1    1\n. 3   48 250  0    0   1    1\n. 4   72 250  0    0   1    1\n. 5   96 250  0    0   1    1\n. 6  120 250  0    0   1    1\n. 7  144 250  0    0   1    1\n\n\nIn this regimen, we have daily dosing for 7 doses. The last dose is given at 144 hours. When putting this into a sequence, we’ll wait one dosing interval and then the wait period and then start again\n\nev_repeat(e3, n = 3, wait = 7*24)\n\n.   time amt ii addl cmt evid\n. 1    0 500 24    0   1    1\n. 2   24 250 24    5   1    1\n. 3  336 500 24    0   1    1\n. 4  360 250 24    5   1    1\n. 5  672 500 24    0   1    1\n. 6  696 250 24    5   1    1\n\n\n\n\n4.5.4 Create a “data_set”\nUse the as_data_set() function to combine multiple event objects into a single data set.\n\nas_data_set(e1, e2)\n\n.   ID time cmt evid amt ii addl\n. 1  1    0   1    1 500 24    0\n. 2  2    0   1    1 250 24    5\n\n\nIt’s important to note that\n\nThe result is a regular old data.frame(); once you call as_data_set(), you exit the event object world\nEach event object is given a different ID\n\nRecall that we can create event objects with multiple IDs; as_data_set() is handy to use with this feature\n\nas_data_set(\n  ev(amt = 100, ID = 1:3), \n  ev(amt = 200, ID = 1:3), \n  ev(amt = 300, ID = 1:2)\n)\n\n.   ID time cmt evid amt\n. 1  1    0   1    1 100\n. 2  2    0   1    1 100\n. 3  3    0   1    1 100\n. 4  4    0   1    1 200\n. 5  5    0   1    1 200\n. 6  6    0   1    1 200\n. 7  7    0   1    1 300\n. 8  8    0   1    1 300\n\n\nNotice that as_data_set has created unique IDs for the 3 subjects in the 100 mg group, the 3 subjects in the 200 mg group, and the 2 subjects in the 300 mg group.\nWe’ll cover a function called ev_rep() below to “expand” an event object to multiple individuals\n\nas_data_set(\n  e1 %>% ev_rep(1:300),\n  e2 %>% ev_rep(1:300)\n)"
  },
  {
    "objectID": "event.html#modifying-an-event-object",
    "href": "event.html#modifying-an-event-object",
    "title": "4  Event objects",
    "section": "4.6 Modifying an event object",
    "text": "4.6 Modifying an event object\n\n4.6.1 Tidy-like manipulation\nEvent objects can be mutated\n\nmutate(e, amt = 200)\n\n. Events:\n.   time amt rate cmt evid\n. 1    1 200   50   2    1\n\n\nColumns can be removed from event objects\n\nev(amt = 100, WT = 50, AGE = 12) %>% select(-WT)\n\n. Events:\n.   time amt cmt evid AGE\n. 1    0 100   1    1  12\n\n\nRows can be removed from event objects\n\ne <- c(ev(amt = 100), ev(amt = 200, time = 12), ev(amt = 300, time = 24))\n\nfilter(e, time <= 12)\n\n. Events:\n.   time amt cmt evid\n. 1    0 100   1    1\n. 2   12 200   1    1\n\n\n\n\n4.6.2 realize_addl\n“Additional” doses can be made explicit in an event object\n\nev(amt = 100, ii = 6, addl = 3) %>% realize_addl()\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100  0    0   1    1\n. 2    6 100  0    0   1    1\n. 3   12 100  0    0   1    1\n. 4   18 100  0    0   1    1\n\n\n\n\n4.6.3 ev_rep\nEvent objects can be “expanded” into multiple IDs to create a population; use the ev_rep() function for this.\n\nev(amt = 100) %>% ev_rep(1:5)\n\n.     ID time amt cmt evid\n. 1    1    0 100   1    1\n. 1.1  2    0 100   1    1\n. 1.2  3    0 100   1    1\n. 1.3  4    0 100   1    1\n. 1.4  5    0 100   1    1\n\n\nBy default, ev_rep() returns a regular data frame. You can request that an event object is returned\n\nev(amt = 100) %>% ev_rep(1:5, as.ev = TRUE)\n\nev_rep() can work on an event object with any complexity."
  },
  {
    "objectID": "event.html#creative-composition",
    "href": "event.html#creative-composition",
    "title": "4  Event objects",
    "section": "4.7 Creative composition",
    "text": "4.7 Creative composition\nmrgsolve has a couple of more creative ways to construct event objects.\n\n4.7.1 ev_days\nev_days() will create dosing sequences when dosing are on certain days (of the week). For example, to dose only on Monday, Wednesday, and Friday for on month\n\ne <- ev_days(ev(amt = 100), ii = 168, addl = 3, days = 'm,w,f')\ne\n\n.   time amt cmt evid  ii addl\n. 1    0 100   1    1 168    3\n. 2   48 100   1    1 168    3\n. 3   96 100   1    1 168    3\n\n\nWe can see how this works by simulating the regimen\n\nmrgsim_e(mod, e, end = 168*4) %>% plot(\"CP\")\n\n\n\n\n\n\n4.7.2 ev_rx\nev_rx() is a way to write a regimen out with notation similar to what you might see on a prescription. For example, 100 mg twice daily for 3 doses into compartment 2 would be\n\nev_rx(\"100 mg q12h x3 in 2\")\n\n. Events:\n.   time amt ii addl cmt evid\n. 1    0 100 12    2   2    1\n\n\nTo code an infusion\n\nev_rx(\"500 mg over 2 hours q 24 h x3 in 1\")\n\n. Events:\n.   time amt rate ii addl cmt evid\n. 1    0 500  250 24    2   1    1\n\n\nSee the ev_rx() documentation for more details and limitations."
  },
  {
    "objectID": "event.html#sec-evd",
    "href": "event.html#sec-evd",
    "title": "4  Event objects",
    "section": "4.8 Upper case names",
    "text": "4.8 Upper case names\nYou’ll notice in the previous sections that most of the column names were rendered with lower case letters when we convert the event object to a data set like object:\n\nas.data.frame(ev(amt = 100))\n\n.   time amt cmt evid\n. 1    0 100   1    1\n\n\nAnd when this event object is use to simulate, you’ll see these lower case names in the simulated output. The reasons for this are historical and this behavior is unlikely to change because it goes so far back into the history of mrgsolve.\nNevertheless, recent versions of mrgsolve have included similar constructor functions that will render column names in upper case which are commonly seen in analysis data sets.\nThe evd() constructor behaves just like ev(), but it will render upper case names when coerced to a data set or used for simulation.\n\ne <- evd(amt = 100)\n\ne\n\n. Events Data:\n.   time amt cmt evid\n. 1    0 100   1    1\n\n\nThe d in evd() indicates that the event object will render with names like a Data set and you will see a reminder of the data set like nature of this object when it is printed.\nWhen this object is rendered to a data frame, you will see the names rendered in upper case\n\nas.data.frame(e)\n\n.   TIME AMT CMT EVID\n. 1    0 100   1    1\n\n\nYou can also coerce an event object created with ev() to one that behaves as if it were created via evd()\n\nas.evd(ev(amt = 100))\n\n. Events Data:\n.   time amt cmt evid\n. 1    0 100   1    1\n\n\nIt is important to note that the case of the column names aren’t made upper case until the data frame is rendered. So, in the previous example, time and amt are in lower case because we have not rendered yet. If you want to work on this object before it is rendered, be sure to lower case names before rendering and upper case after rendering. For example we use rate in the the following example, not RATE:\n\nevd(amt = 100) %>% mutate(rate = amt / 5)\n\n. Events Data:\n.   time amt rate cmt evid\n. 1    0 100   20   1    1\n\n\nYou can coerce a traditional event object to a data like event object with\n\nas.evd(ev(amt = 100))\n\n. Events Data:\n.   time amt cmt evid\n. 1    0 100   1    1\n\n\nAnd finally, there are two utility functions for changing the names of a data like or event object. To convert to upper case use uctran()\n\nev(amt = 100) %>% as_data_set() %>% uctran()\n\n.   TIME AMT CMT EVID ID\n. 1    0 100   1    1  1\n\n\nTo convert to lower case, use lctran()\n\nevd(amt = 100) %>% as_data_set() %>% lctran()\n\n.   time amt cmt evid ID\n. 1    0 100   1    1  1\n\n\nThe utility functions also work on event objects. For example,\n\nev(amt = 100) %>% uctran()\n\n. Events Data:\n.   time amt cmt evid\n. 1    0 100   1    1"
  },
  {
    "objectID": "matrix.html#basics",
    "href": "matrix.html#basics",
    "title": "5  Model Matrices",
    "section": "5.1 Basics",
    "text": "5.1 Basics\n\n5.1.1 Simple matrix lists\nWe can look at the popex model in the internal library for a starting example to show how model matrices can be seen from the model object.\nOnce the model is loaded\n\nmod <- modlib(\"popex\", compile = FALSE)\n\nWe can print the model object to the console and see the matrix structure\n\nmod\n\n. \n. \n. ----------------  source: popex.cpp  ----------------\n. \n.   project: /Users/kyleb/Rli...gsolve/models\n.   shared object: popex-so-f0f3bbca0dd <not loaded>\n. \n.   time:          start: 0 end: 240 delta: 0.5\n.                  add: <none>\n. \n.   compartments:  GUT CENT [2]\n.   parameters:    TVKA TVCL TVV WT [4]\n.   captures:      CL V ECL IPRED DV [5]\n.   omega:         3x3 \n.   sigma:         1x1 \n. \n.   solver:        atol: 1e-08 rtol: 1e-08 maxsteps: 20k\n. ------------------------------------------------------\n\n\nIn this output, we see that omega is a 3 by 3 matrix and sigma is 1 by 1. We can view both matrices by calling revar() on the model object\n\nrevar(mod)\n\n. $omega\n. $...\n.       [,1] [,2] [,3]\n. ECL:   0.3  0.0  0.0\n. EV:    0.0  0.1  0.0\n. EKA:   0.0  0.0  0.5\n. \n. \n. $sigma\n. $...\n.     [,1]\n. 1:     0\n\n\nThis shows the 3x3 $OMEGA matrix with all off-diagonals set to zero and the 1x1 $SIGMA which is currently fixed to 0.\nThe $OMEGA matrix can be extracted with the omat() function\n\nomat(mod)\n\n. $...\n.       [,1] [,2] [,3]\n. ECL:   0.3  0.0  0.0\n. EV:    0.0  0.1  0.0\n. EKA:   0.0  0.0  0.5\n\n\nUse the smat() function to extract the $SIGMA matrix. The result of these calls are matlist objects; for $OMEGA the class is omegalist (which inherits from matlist)\n\nomat(mod) %>% class()\n\n. [1] \"omegalist\"\n. attr(,\"package\")\n. [1] \"mrgsolve\"\n\n\nand for $SIGMA it is sigmalist. These are lists of matrices. In this example, there is just one $OMEGA block in the code\n\nblocks(mod, OMEGA)\n\n. \n. Model file: popex.cpp \n. \n. $OMEGA\n. @labels ECL EV EKA\n. 0.3 0.1 0.5\n\n\nso the length of the omegalist object is also 1\n\nom <- omat(mod)\nlength(om)\n\n. [1] 1\n\n\nFunctions are provided to check the names\n\nnames(om)\n\n. [1] \"...\"\n\n\nand the labels\n\nlabels(om)\n\n. [[1]]\n. [1] \"ECL\" \"EV\"  \"EKA\"\n\n\nas well as getting the dimensions or number of rows\n\ndim(om)\n\n. $...\n. [1] 3 3\n\n\n\nnrow(om)\n\n. ... \n.   3\n\n\nThe omegalist (sigmalist) object can be converted to a standard R list\n\nas.list(om) %>% str()\n\n. List of 1\n.  $ ...: num [1:3, 1:3] 0.3 0 0 0 0.1 0 0 0 0.5\n.   ..- attr(*, \"dimnames\")=List of 2\n.   .. ..$ : chr [1:3] \"ECL\" \"EV\" \"EKA\"\n.   .. ..$ : chr [1:3] \"ECL\" \"EV\" \"EKA\"\n\n\nor it can be rendered as a matrix\n\nas.matrix(om)\n\n.      [,1] [,2] [,3]\n. [1,]  0.3  0.0  0.0\n. [2,]  0.0  0.1  0.0\n. [3,]  0.0  0.0  0.5\n\n\n\n\n5.1.2 Multiple matrix lists\nLet’s look at an example where there is a more complicated $OMEGA structure.\n\n// inline/multiple-matrices.cpp\n \n$OMEGA @name first @labels a b c\n1 2 3\n\n$OMEGA @name second @labels d e\n4 5\n\n$OMEGA @name third @labels f g h i\n6 7 8 9\n\n\nmod <- mread(\"inline/multiple-matrices.cpp\", quiet = TRUE)\n\nEach $OMEGA block codes a diagonal matrix; the interesting feature is that there are 3 different $OMEGA blocks.\nNow, when we look at the model\n\nmod\n\n. \n. \n. ----------  source: multiple-matrices.cpp  ----------\n. \n.   project: /Users/kyleb/git...-guide/inline\n.   shared object: multiple-matrices.cpp-so-f0f44e8102b \n. \n.   time:          start: 0 end: 24 delta: 1\n.                  add: <none>\n. \n.   compartments:  <none>\n.   parameters:    <none>\n.   captures:       <none>\n.   omega:         3x3,2x2,4x4 \n.   sigma:         0x0 \n. \n.   solver:        atol: 1e-08 rtol: 1e-08 maxsteps: 20k\n. ------------------------------------------------------\n\n\nWe see that $OMEGA is one 3x3 matrix, one 2x2 matrix and on 4x4 matrix, in that order. Calling revar() on this model object\n\nrevar(mod)\n\n. $omega\n. $first\n.     [,1] [,2] [,3]\n. a:     1    0    0\n. b:     0    2    0\n. c:     0    0    3\n. \n. $second\n.     [,1] [,2]\n. d:     4    0\n. e:     0    5\n. \n. $third\n.     [,1] [,2] [,3] [,4]\n. f:     6    0    0    0\n. g:     0    7    0    0\n. h:     0    0    8    0\n. i:     0    0    0    9\n. \n. \n. $sigma\n. No matrices found\n\n\nwe only see the $OMEGA matrices as the model was coded. Now the length of the omegalist object is 3\n\nlength(omat(mod))\n\n. [1] 3\n\n\nand the number of rows is 3 in the first matrix, 2 in the second, and 4 in the third\n\nnrow(omat(mod))\n\n.  first second  third \n.      3      2      4\n\n\nWe can also check dim()\n\ndim(omat(mod))\n\n. $first\n. [1] 3 3\n. \n. $second\n. [1] 2 2\n. \n. $third\n. [1] 4 4\n\n\nThe omega matrix can be converted from this segmented list into a single block matrix\n\nas.matrix(omat(mod))\n\n.       [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n.  [1,]    1    0    0    0    0    0    0    0    0\n.  [2,]    0    2    0    0    0    0    0    0    0\n.  [3,]    0    0    3    0    0    0    0    0    0\n.  [4,]    0    0    0    4    0    0    0    0    0\n.  [5,]    0    0    0    0    5    0    0    0    0\n.  [6,]    0    0    0    0    0    6    0    0    0\n.  [7,]    0    0    0    0    0    0    7    0    0\n.  [8,]    0    0    0    0    0    0    0    8    0\n.  [9,]    0    0    0    0    0    0    0    0    9\n\n\nThe result is 9x9 with all off diagonals between the different list positions set to zero.\nOtherwise, we might work with this object as a list\n\nas.list(omat(mod))\n\n. $first\n.   a b c\n. a 1 0 0\n. b 0 2 0\n. c 0 0 3\n. \n. $second\n.   d e\n. d 4 0\n. e 0 5\n. \n. $third\n.   f g h i\n. f 6 0 0 0\n. g 0 7 0 0\n. h 0 0 8 0\n. i 0 0 0 9"
  },
  {
    "objectID": "matrix.html#collapsing-matrices",
    "href": "matrix.html#collapsing-matrices",
    "title": "5  Model Matrices",
    "section": "5.2 Collapsing matrices",
    "text": "5.2 Collapsing matrices\nThe functionality described in this subsection is new with mrgsolve 1.0.0.\nThe structure of the matrices and the order in which they appear in the list matter when updating each matrix (see below). We saw how to create one big matrix out of all the smaller matrices using the as.matrix(). This section describes how to combine matrices within the confines of the matlist object.\nmrgsolve provides functions to collapse (or combine) matrices in a matlist object. We can call collapse_omega(), passing in the model object\n\ncollapse_omega(mod) %>% revar()\n\n. $omega\n. $...\n.     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n. a:     1    0    0    0    0    0    0    0    0\n. b:     0    2    0    0    0    0    0    0    0\n. c:     0    0    3    0    0    0    0    0    0\n. d:     0    0    0    4    0    0    0    0    0\n. e:     0    0    0    0    5    0    0    0    0\n. f:     0    0    0    0    0    6    0    0    0\n. g:     0    0    0    0    0    0    7    0    0\n. h:     0    0    0    0    0    0    0    8    0\n. i:     0    0    0    0    0    0    0    0    9\n. \n. \n. $sigma\n. No matrices found\n\n\nand now we have an omegalist object inside a model object and the matrix is a single 9x9 $OMEGA matrix. The row names have been retained, but there is now no name for the matrix; this can be provided when collapsing\n\ncollapse_omega(mod, name = \"only\") %>% omat()\n\n. $only\n.     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9]\n. a:     1    0    0    0    0    0    0    0    0\n. b:     0    2    0    0    0    0    0    0    0\n. c:     0    0    3    0    0    0    0    0    0\n. d:     0    0    0    4    0    0    0    0    0\n. e:     0    0    0    0    5    0    0    0    0\n. f:     0    0    0    0    0    6    0    0    0\n. g:     0    0    0    0    0    0    7    0    0\n. h:     0    0    0    0    0    0    0    8    0\n. i:     0    0    0    0    0    0    0    0    9\n\n\nSuppose that we only want to combine the first two matrices, leaving the third matrix alone. In that case, call collapse_omega() with the range argument\n\ncollapse_omega(mod, range = c(1,2), name = \"first_second\") %>% omat()\n\n. $first_second\n.     [,1] [,2] [,3] [,4] [,5]\n. a:     1    0    0    0    0\n. b:     0    2    0    0    0\n. c:     0    0    3    0    0\n. d:     0    0    0    4    0\n. e:     0    0    0    0    5\n. \n. $third\n.     f g h i\n. f:  6 0 0 0\n. g:  0 7 0 0\n. h:  0 0 8 0\n. i:  0 0 0 9\n\n\nNow the matlist topology has changed; there are still 9 (total) rows and columns, but the matlist object is length 2 with 5x5 in the first position (newly named first_second) an the old 4x4 matrix in the second position. Collapsing matrices is an irreversible process; at this time there is no mechanism to cut matrices back into smaller chunks. But collapsing matrices can be very helpful when they need to be updated.\nUse collapse_sigma() to collapse $SIGMA matrices if needed.\nAlso, the function collapse_matrix() can be called on a omegalist or sigmalist object to collapse\n\nomat(mod) %>% collapse_matrix(range = c(2,NA))\n\n. $first\n.     a b c\n. a:  1 0 0\n. b:  0 2 0\n. c:  0 0 3\n. \n. $...\n.     [,1] [,2] [,3] [,4] [,5] [,6]\n. d:     4    0    0    0    0    0\n. e:     0    5    0    0    0    0\n. f:     0    0    6    0    0    0\n. g:     0    0    0    7    0    0\n. h:     0    0    0    0    8    0\n. i:     0    0    0    0    0    9"
  },
  {
    "objectID": "matrix.html#sec-matrix-update",
    "href": "matrix.html#sec-matrix-update",
    "title": "5  Model Matrices",
    "section": "5.3 Updating $OMEGA and $SIGMA  ",
    "text": "5.3 Updating $OMEGA and $SIGMA  \nLike the values of parameters in the parameter list, we may want to update the values in $OMEGA and $SIGMA matrices. We can do so without re-compiling the model.\n\n5.3.1 Matrix helper functions\nmrgsolve keeps $OMEGA and $SIGMA in block matrices (regardless of whether the off-diagonal elements are zeros or not). Recall that in the model specification file we can enter data for $OMEGA and $SIGMA as the lower triangle of the matrix (see Section 2.2.17). In R, we need to provide a matrix (as an R object). mrgsolve provides some convenience functions to help … allowing the user to enter lower diagonals instead of the full matrix.\ndmat() for diagonal matrix\n\ndmat(1,2,3)\n\n.      [,1] [,2] [,3]\n. [1,]    1    0    0\n. [2,]    0    2    0\n. [3,]    0    0    3\n\n\nbmat() for block matrix\n\nbmat(1,2,3)\n\n.      [,1] [,2]\n. [1,]    1    2\n. [2,]    2    3\n\n\ncmat() for a block matrix where the diagonal elements are variances and the off-diagonals are taken to be correlations, not covariances\n\ncmat(0.1, 0.87,0.3)\n\n.           [,1]      [,2]\n. [1,] 0.1000000 0.1506884\n. [2,] 0.1506884 0.3000000\n\n\nmrgsolve will convert the correlations to covariances.\nmrgsolve also provides as_bmat() and as_dmat() for converting other R objects to matrices or lists of matrices.\nConsider this list with named elements holding the data for a matrix:\n\nm <- list(OMEGA1.1 = 0.9, OMEGA2.1 = 0.3, OMEGA2.2 = 0.4)\n\nThese data could form either a 3x3 diagonal matrix or a 2x2 block matrix. But the names suggest a 2x2 form. as_bmat() can make the matrix like this\n\nas_bmat(m, \"OMEGA\")\n\n.      [,1] [,2]\n. [1,]  0.9  0.3\n. [2,]  0.3  0.4\n\n\nThe second argument is a regular expression that mrgsolve uses to find elements in the list to use for building the matrix.\nFrequently, we have estimates in a data frame like this\n\ndata(exBoot)\nhead(exBoot)\n\n.   run  THETA1 THETA2  THETA3 OMEGA11   OMEGA21 OMEGA22 OMEGA31  OMEGA32 OMEGA33\n. 1   1 -0.7634  2.280  0.8472 0.12860  0.046130  0.2874 0.13820 -0.02164  0.3933\n. 2   2 -0.4816  2.076  0.5355 0.12000  0.051000  0.2409 0.06754 -0.07759  0.3342\n. 3   3 -0.5865  2.334 -0.4597 0.11460  0.097150  0.2130 0.16650  0.18100  0.4699\n. 4   4 -0.6881  1.824  0.7736 0.14990  0.000003  0.2738 0.24700 -0.05466  0.5536\n. 5   5  0.2909  1.519 -1.2440 0.07308  0.003842  0.2989 0.06475  0.05078  0.2500\n. 6   6  0.1135  2.144 -1.0040 0.13390 -0.019270  0.1640 0.10740 -0.01170  0.3412\n.    SIGMA11 SIGMA21 SIGMA22\n. 1 0.002579       0  1.0300\n. 2 0.002228       0  1.0050\n. 3 0.002418       0  1.0890\n. 4 0.002177       0  0.8684\n. 5 0.001606       0  0.8996\n. 6 0.002134       0  0.9744\n\n\nWe can use as_bmat() with this data frame to extract the $OMEGA matrices\n\nomegas <- as_bmat(exBoot, \"OMEGA\")\nlength(omegas)\n\n. [1] 100\n\ndim(exBoot)\n\n. [1] 100  13\n\nomegas[[6]]\n\n.          [,1]     [,2]    [,3]\n. [1,]  0.13390 -0.01927  0.1074\n. [2,] -0.01927  0.16400 -0.0117\n. [3,]  0.10740 -0.01170  0.3412\n\nomegas[[16]]\n\n.         [,1]    [,2]   [,3]\n. [1,] 0.08126 0.01252 0.1050\n. [2,] 0.01252 0.16860 0.0149\n. [3,] 0.10500 0.01490 0.4062\n\n\nThe result of calling as_bmat or as_dmat is a list of matrices, one for each row in the data frame.\nNote in this example, we could have called\n\nsigmas <- as_bmat(exBoot,\"SIGMA\") \n\nto grab the $SIGMA matrices.\nFor help on these helper functions, see ?dmat, ?bmat, ?cmat, ?as_bmat, ?as_dmat in the R help system after loading mrgsolve.\n\n\n5.3.2 Fill a matrix with zeros\nSometimes we write a population model that includes random effects, but we would like to simulate from that same model without the random effects implemented. For example, we want to simulate some typical PK profiles from a population PK model that includes IIV on some parameters and / or RUV on the simulated outputs.\nTo do this, pass the model through the zero_re() function. By default, this will convert all $OMEGA and $SIGMA matrix elements to zeros. See the R help file (?zero_re) to see some options for selectively zeroing out only one or the other.\nFor example we have this population PK model\n\nmod <- modlib(\"popex\", compile = FALSE)\n\nomat(mod)\n\n. $...\n.       [,1] [,2] [,3]\n. ECL:   0.3  0.0  0.0\n. EV:    0.0  0.1  0.0\n. EKA:   0.0  0.0  0.5\n\n\nWe can turn that matrix to all zeros with\n\nmod %>% zero_re() %>% omat()\n\n. $...\n.       [,1] [,2] [,3]\n. ECL:     0    0    0\n. EV:      0    0    0\n. EKA:     0    0    0\n\n\nAnd when we simulate right after that, all ETA(n) will be zero as well and you’ll get your fixed-effects simulation (the following is for example only and is not evaluated)\n\nmod %>% \n  zero_re() %>% \n  ev(amt = 100) %>% \n  mrgsim() %>%\n  plot()\n\n\n\n5.3.3 Example: unnamed matrix\nHere is a model with only a 3x3 $OMEGA matrix\n\n// inline/matrix.cpp\n \n$OMEGA\n1 2 3\n\n\nmod <- mread(\"inline/matrix.cpp\", compile = FALSE, quiet = TRUE)\n\nLet’s check the values in the matrix using omat()\n\nmod %>% omat\n\n. $...\n.     [,1] [,2] [,3]\n. 1:     1    0    0\n. 2:     0    2    0\n. 3:     0    0    3\n\n\nWe also use omat() to update the values in the matrix\n\nmod %>% omat(dmat(4,5,6)) %>% omat\n\n. $...\n.     [,1] [,2] [,3]\n. 1:     4    0    0\n. 2:     0    5    0\n. 3:     0    0    6\n\n\nTo update $OMEGA, we must provide a matrix of the same dimension, in this case 3x3. An error is generated if we provide a matrix with the wrong dimension.\n\nans <- try(mod %>% omat(dmat(11,23)))\n\n. Error : improper signature: omat\n\nans\n\n. [1] \"Error : improper signature: omat\\n\"\n. attr(,\"class\")\n. [1] \"try-error\"\n. attr(,\"condition\")\n. <simpleError: improper signature: omat>\n\n\n\n\n5.3.4 Example: named matrices\nWhen there are multiple $OMEGA matrices, it can be helpful to assign them names. Here, there are two matrices: one for interindividual variability (IIV) and one for interoccasion variability (IOV).\n\n// inline/iov.cpp\n \n$OMEGA @name IIV\n1 2 3\n$OMEGA @name IOV\n4 5\n\n\nmod <- mread(\"inline/iov.cpp\", compile = FALSE, quiet = TRUE)\n\nrevar(mod)\n\n. $omega\n. $IIV\n.     [,1] [,2] [,3]\n. 1:     1    0    0\n. 2:     0    2    0\n. 3:     0    0    3\n. \n. $IOV\n.     [,1] [,2]\n. 4:     4    0\n. 5:     0    5\n. \n. \n. $sigma\n. No matrices found\n\n\nNow, we can update either IIV or IOV (or both) by name\n\nmod %>% \n  omat(IOV = dmat(11,12), IIV = dmat(13, 14, 15)) %>% \n  omat()\n\n. $IIV\n.     [,1] [,2] [,3]\n. 1:    13    0    0\n. 2:     0   14    0\n. 3:     0    0   15\n. \n. $IOV\n.     [,1] [,2]\n. 4:    11    0\n. 5:     0   12\n\n\nAgain, an error is generated if we try to assign a 3x3 matrix to the IOV position\n\nans <- try(mod %>% omat(IIV = dmat(1, 2)))\n\n. Error : improper dimension: omat\n\nans\n\n. [1] \"Error : improper dimension: omat\\n\"\n. attr(,\"class\")\n. [1] \"try-error\"\n. attr(,\"condition\")\n. <simpleError: improper dimension: omat>\n\n\n\n\n5.3.5 Example: unnamed matrices\nIf we do write the model with unnamed matrices, we can still update them\n\n// inline/multi.cpp\n \n$OMEGA\n1 2 3\n\n$OMEGA \n4 5\n\n\nmod <- mread(\"inline/multi.cpp\", compile = FALSE, quiet = TRUE)\n\nIn this case, the only way to update is to pass in a list of matrices, where (in this example) the first matrix is 3x3 and the second is 2x2\n\nmod %>% omat(list(dmat(5, 6, 7), dmat(8, 9))) %>% omat()\n\n. $...\n.     [,1] [,2] [,3]\n. 1:     5    0    0\n. 2:     0    6    0\n. 3:     0    0    7\n. \n. $...\n.     [,1] [,2]\n. 4:     8    0\n. 5:     0    9"
  },
  {
    "objectID": "output.html#output-types",
    "href": "output.html#output-types",
    "title": "6  Simulated output",
    "section": "6.1 Output types",
    "text": "6.1 Output types\nWhen mrgsim() is used to simulate from a model, it by default returns an object with class mrgsims. This is an S4 object containing a data.frame of simulated output and a handful of other pieces of data related to the simulation run that can be coerced to other types (like data.frame or tibble).\nFor simulations with large outputs or extremely brief simulations where efficiency is important, users can request the output be returned as a data frame. This is most efficient when the features provided by the mrgsims object are not needed. To do this, pass the output argument to mrgsim()\n\nout <- mrgsim(mod, ..., output = \"df\")\n\nor use mrgsim_df()\n\nout <- mrgsim_df(mod, ....)"
  },
  {
    "objectID": "output.html#methods-for-mrgsim-output",
    "href": "output.html#methods-for-mrgsim-output",
    "title": "6  Simulated output",
    "section": "6.2 Methods for mrgsim output",
    "text": "6.2 Methods for mrgsim output\nmrgsolve provides several methods for working with mrgsims objects or coercing the simulation matrix into other R objects. Note the discussion in the following subsections all refer to working with mrgsims objects, not data.frame output.\n\n6.2.1 Coercion methods\n\nas_tibble(): convert to tibble\nas.data.frame(): convert to data.frame\nas.matrix(): convert to matrix\n\n\n\n6.2.2 Query methods\n\nhead(): shows the first n = 5 rows\ntail(): shows the last n = 5 rows\nnames(): shows the column names\ndim(): shows the number of rows and columns\nsummary(): shows a numeric summary of all columns\n$: extracts a column\n\n\n\n6.2.3 Graphical methods\nThere is a plot() methods for simulated output that is aware of independent and dependent variables from the simulation. If out is the simulated output (an mrgsims object)\n\nplot(out)\n\nPlot with a formula; the following example selects only the CP and RESPONSE outputs and plots them versus time\n\nplot(out, CP + RESPONSE ~ time)\n\nTo select a large number of responses to plot, pass a character vector or comma-separated character data containing output columns to plot\n\nplot(out, \"CP, RESPONSE, WT, DOSE\")\n\n\n\n6.2.4 Methods for dplyr verbs\nmrgsolve provides several S3 methods to make it possible to include dplyr verbs in your simulation pipeline.\nFor example\n\nlibrary(dplyr)\nlibrary(mrgsolve)\n\nmod <- house()\n\nmod %>% \n  ev(amt=100) %>%\n  mrgsim() %>% \n  filter(time >= 10)\n\nHere, mrgsim() returns an mrgsims object. When dplyr is also loaded, this object can be piped directly to dplyr::filter() or dplyr::mutate() etc.\nIt is important to note that when mrgsims output is piped to dplyr functionality, it is coerced to tibble (data.frame) and there is no way to get the data back to mrgsims object. Most of the time, this is desirable and there is no need to explicitly coerce to tibble() when calling dplyr verbs on simulated output.\nOther dplyr functions that can be used with mrgsims objects\n\ngroup_by()\nmutate()\nfilter()\nsummarise()\nselect()\nslice()\npull()\ndistinct()\nslice()\n\n\n\n6.2.5 Modify methods\nYou can modify the underlying data in the mrgsims object and keep it as an mrgsims object.\n\nfilter_sims(): calls dplyr::filter() to pick rows to keep or discard\nselect_sims(): calls dplyr::select(); note that ID and time columns are always retained\nmutate_sims(): calls dplyr::mutate() to add or modify columns"
  },
  {
    "objectID": "output.html#controlling-output-scope",
    "href": "output.html#controlling-output-scope",
    "title": "6  Simulated output",
    "section": "6.3 Controlling output scope",
    "text": "6.3 Controlling output scope\n\n6.3.1 Background\nLimiting the volume of simulated data can have a major impact on simulation efficiency, memory footprint, and ease (or lack of ease) in reviewing and dealing with the output. For any large simulation or any simulation from a large model, the user should consider selecting what gets returned when the simulation is performed.\nBy default, mrgsim() returns a data.frame with the following\n\nID: regardless of whether you simulated a population or not\ntime / TIME: the independent variable\nSimulated values for all model compartments\nSimulated values for derived outputs listed in $CAPTURE\n\nYou will always get ID and time and the compartments and any captured items must be written into the model file. This defines the list of data items that could (possibly) get returned under items 3 and 4 above. Again: this must be written into the model file and is locked at the time the model is compiled.\nHowever, mrgsolve allows the user to pick what is actually returned at run time. Because this is done at run time, different runs can return different data items. And (importantly) mrgsim() only allocates space in the output for data items that are requested. So, opting out of unneeded outputs will decrease memory consumption and increase efficiency.\n\n\n6.3.2 Implementation\nThe mrgsolve model object tracks compartments and captures that are currently being requested. This can be queried using outvars()\n\nmod <- house()\n\noutvars(mod)\n\n. $cmt\n. [1] \"GUT\"  \"CENT\" \"RESP\"\n. \n. $capture\n. [1] \"DV\" \"CP\"\n\n\nItems are listed under cmt and capture. The user can update the model object with the names of columns that are being requested by passing outvars to update()\n\nmod <- update(mod, outvars = \"CP, RESP\")\n\noutvars(mod)\n\n. $cmt\n. [1] \"RESP\"\n. \n. $capture\n. [1] \"CP\"\n\n\nThis will exclude anything that isn’t named in the update. The outvars list can be reset by passing (all)\n\nmod <- update(mod, outvars = \"(all)\")\n\nRemember that ... passed to mrgsim() are also passed to update() so it is possible to select outputs right in your mrgsim() call\n\nout <- mrgsim(mod, outvars = \"CP, RESP\")\n\n\n\n6.3.3 Copy items from data to simulated output\nUsers can also use carry_out and recover to copy items from the input data into the output. This is covered in a different chapter."
  },
  {
    "objectID": "sequence.html#functions-to-call",
    "href": "sequence.html#functions-to-call",
    "title": "7  Simulation sequence",
    "section": "7.1 Functions to call",
    "text": "7.1 Functions to call\nThe model specification results in the definition of four functions that mrgsolve calls during the simulation sequence. Naming them by their code block identifiers, the functions are\n\n$PREAMBLE\n$MAIN\n$ODE\n$TABLE"
  },
  {
    "objectID": "sequence.html#problem-initiation",
    "href": "sequence.html#problem-initiation",
    "title": "7  Simulation sequence",
    "section": "7.2 Problem initiation",
    "text": "7.2 Problem initiation\nJust prior to starting the problem (when NEWIND is equal to 0), mrgsolve calls $PREAMBLE. This function is only called once during the simulation sequence. The goal of $PREAMBLE is to allow the user to work with different C++ data structures to get them ready for the simulation run."
  },
  {
    "objectID": "sequence.html#subject-initiation",
    "href": "sequence.html#subject-initiation",
    "title": "7  Simulation sequence",
    "section": "7.3 Subject initiation",
    "text": "7.3 Subject initiation\nAfter the $PREAMBLE call, mrgsolve simulates each ID in the data set, one after another. mrgsolve runs this sequence just prior to simulating a given ID\n\nCopy any parameters that are found in the idata_set to the working parameter list\nCopy any parameters that are found in the data_set to the working parameter list, with the copy being taken from the first actual data set row for that individual. If the first actual data set record in the data set is not the first record for the individual, mrgsolve still copies from the first data set record as long as the fillbak argument to mrgsim is TRUE.\nSet initial estimates from the base initial estimate list\nCopy initial estimates from idata_set if they are found there.\nCall $MAIN\nStart simulating the records for that individual"
  },
  {
    "objectID": "sequence.html#sequence-for-a-single-record",
    "href": "sequence.html#sequence-for-a-single-record",
    "title": "7  Simulation sequence",
    "section": "7.4 Sequence for a single record",
    "text": "7.4 Sequence for a single record\nmrgsolve executes this sequence while working from record to record for a given ID\n\nIf nocb (next observation carried backward) is TRUE, then parameters are copied from the current record if that is an actual data set record. Note that if nocb is FALSE then locf (first observation carried forward) is assumed to be TRUE (see below). This is the last parameters will be copied from any input data set prior to advancing the system (when locf is being used). Therefore, when parameter columns are found in both an idata_set and a data_set, it will be the value found in the data_set that will overwrite both the base list and any parameter value that was copied from an idata_set. It is not an error to have different parameter values in an idata_set and a data-set, but the value found in the data_set will be used when this happens. More on parameters and the parameter update sequence can be found in Section 11.3 and Section 1.1.\n$MAIN is called\nThe system is advanced via $ODE or $PKMODEL, whichever one is invoked in the model specification file.\nIf the current record is a dosing record, the dose is implemented (e.g. bolus made or infusion started).\nIf the system is advancing according to locf, then parameters are copied from the current record if that is an actual data set record. This is in contrast to nocb advance (see above).\nThe $TABLE function is called\nIf the current record is marked for inclusion in the simulated output, results are written to the output matrix.\nContinue to the next record in the individual.\nOnce the last record is processed in an individual, a new individual is started."
  },
  {
    "objectID": "steady-state.html#key-information",
    "href": "steady-state.html#key-information",
    "title": "8  Steady state",
    "section": "8.1 Key information",
    "text": "8.1 Key information\nKeep reading for all the details; I’m including this brief list of key items up front for your convenience.\n\nUse ss_rtol and ss_atol arguments to mrgsim() to control the local error estimate when mrgsolve is finding steady state\nUse ss_n to limit the number of doses that will be administered when advancing to steady state; if the number of doses exceeds ss_n then a warning is issued and mrgsolve moves on\nUse ss_fixed = TRUE to silence the warning when ss_n is exceeded; you are essentially saying dose up to ss_n and then give up and move on without warning\nUse SS_ADVANCE in $ODE to check if the system is currently being advanced\nUse ss_cmt in [ set ] (inside your model) to select the compartments to be considered when finding steady state; you might have better success / efficiency if you focus on key compartments (or exclude unhelpful compartments like a depot compartment)"
  },
  {
    "objectID": "steady-state.html#introduction",
    "href": "steady-state.html#introduction",
    "title": "8  Steady state",
    "section": "8.2 Introduction",
    "text": "8.2 Introduction\nWithin mrgsolve, the term “steady state” (SS) applies specifically to the pharmacokinetic dosing system and indicates that the rate of drug administration is equal to the rate of drug elimination. Steady state dosing can take the form of repeated intermittent doses (bolus or infusion, administered intermittently at a given dosing interval) or a continuous infusion administered to steady state.\n\n8.2.1 Intermittent doses\nThe user can direct mrgsolve to advance the system to steady state for intermittent dosing by including ss=1 in an event object or input data set. For example:\n\nmod <- modlib(\"pk1\", end = 120)\n\n. Building pk1 ... done.\n\ndose <- ev(amt = 100, ii = 12, addl = 4, ss = 1)\n\nmrgsim(mod, dose, recsort = 3) %>% plot()\n\n\n\n\nIn this example, the ss=1 flag tells mrgsolve to advance the system to steady state under a dosing regimen of 100 mg every 12 hours (and then give a total of 5 doses). When using the ss=1 flag, the user is required to indicate the dosing interval (here every 12 hours) and additional doses are optional. Similar behavior can be achieved for intermittent infusions by setting the infusion rate.\n\n\n8.2.2 Continuous infusion\nA continuous infusion can be dosed to steady state by including the ss=1 flag, a value for rate (any positive rate or -1 if the rate is being modeled), and setting the dose amount (amt/AMT) to zero:\n\ninfus <- ev(amt = 0, rate = 5, ss = 1, cmt = \"CENT\")\n\nmrgsim(mod, infus, recsort = 3) %>% plot()\n\n\n\n\nBecause CL is equal to 1 in this model, we see that the continuous (never-ending) infusion was started at steady state with a value of 5."
  },
  {
    "objectID": "steady-state.html#advance-to-ss",
    "href": "steady-state.html#advance-to-ss",
    "title": "8  Steady state",
    "section": "8.3 Advance to SS",
    "text": "8.3 Advance to SS\nIt’s important to recognize that SS is related to the PK dosing system; it is finding the state of the system after an infinite number of doses have been administered under a certain regimen. And this is essentially how mrgsolve goes about finding steady state: when the ss=1 flag is encountered, mrgsolve starts repeatedly administering doses and advancing the system to the next dose according to the inter-dose interval (ii). Once mrgsolve determines that the amounts in the system at any dose are the same as they were at the preceding dose, mrgsolve declares that SS has been achieved."
  },
  {
    "objectID": "steady-state.html#control-advance-to-ss",
    "href": "steady-state.html#control-advance-to-ss",
    "title": "8  Steady state",
    "section": "8.4 Control advance to SS",
    "text": "8.4 Control advance to SS\n\n8.4.1 Tolerances for SS\nmrgsolve uses a local error estimate to determine the degree to which concentrations are changing or not changing between doses on the way to SS. This is determined by a relative tolerance parameter (ss_rtol) and an absolute tolerance parameter (ss_atol). As of mrgsolve version 0.10.3, these tolerances are distinct from the tolerances used for solving the differential equations (rtol and atol, respectively). Note that when advancing to SS in an ODE model, ss_rtol (the relative tolerance for determining SS) must be larger (less precise) than rtol (the relative tolerance used by the ODE solver). Once the difference between two trough concentrations is less than A\\(_{trough}\\) * ss_rtol + ss_atol, then the system is said to be at steady state. By default, this calculation is done for every single compartment in the model and all compartments have to meet this criteria before the system is said to be at steady state. So, increasing ss_rtol (say from 1e-8 to 1e-3) will also allow us to call it “good” with respect to steady state sooner.\nBoth tolerances for steady state are stored in the model object and can be set with the update method. For example,\n\nmod <- house()\n\nmod <- update(mod, ss_rtol = 1e-5, ss_atol = 1e-8)\n\n\n\n8.4.2 Max dose number\nIt was noted above that mrgsolve advances the system to steady state with a brute force approach: doses are repeatedly administered at a regular interval (for intermittent SS) until pre-dose concentrations are the same dose to dose. mrgsolve sets an upper limit (equal to 500) to the number of doses that will be administered before giving up on trying to find steady state. Once this maximum number of doses is exceeded, mrgsolve will issue a warning that steady state was not achieved and continue on with the problem. For example:\n\ndose <- ev(amt = 100, ii = 12, ss = 1, VC = 800)\n\nout <- mrgsim(house(), dose)\n\n. Warning in (function (x, data, idata = no_idata_set(), carry_out = carry.out, : [steady_bolus] ID 1 failed to reach steady state\n.   ss_n: 500, ss_rtol: 1e-08, ss_atol: 1e-08\n\n\nHere, mrgsolve administered 500 doses and the pre-dose concentrations were still not similar enough to declare the system to be at steady state.\nThe maximum dose number can be set with the ss_n argument to mrgsim (or one of the variants; see ?do_mrgsim help topic). This number can be increased to prevent the warning:\n\nout <- mrgsim(house(), dose, ss_n  = 1000)\n\nAlternatively, the ss_fixed argument to mrgsim (see ?do_mrgsim) can be set to TRUE to silence the warning. In this case, up to ss_n doses will be administered and if SS is not achieved with that many doses, the problem will continue with no warning.\n\n\n8.4.3 Include / exclude compartments for SS\nSometimes it might be sufficient to only consider one compartment when determining SS (e.g. the central compartment in a PK model). Other times, it might be helpful to exclude a compartment when determining SS (e.g. a depot dosing compartment when concentrations can get very small toward the end of the dosing interval).\nmrgsolve allows the user to identify compartments to include or exclude in determining SS. This is done through the ss_cmt option in $SET. To only consider the CENT compartment, write the following in the model file:\n\n[ set ] ss_cmt = \"CENT\"\n\nThis says to only look at the CENT compartment when determining SS.\nAlternatively, you can exclude certain compartments like this:\n\n[ set ] ss_cmt = \"-GUT,DEPOT\"\n\nThis says to ignore the GUT and DEPOT compartments when determining SS.\nAs another example, you might want to exclude an accumulator compartment when calculating SS\n\n[ set ] ss_cmt = \"-AUC\"\n\n[ ode ] \ndxdt_CENT = -kel * CENT;\n\ndxdt_AUC = CENT/VC;\n\nThis is just a partial model snippet, but it shows how you might exclude the AUC compartment when determining SS.\n\n\n8.4.4 SS_ADVANCE flag\nmrgsolve also provides an SS_ADVANCE indicator that is passed into $ODE and evaluates to true when the system is being advanced to steady state. So a better way to exclude the accumulator compartment from being considered for SS calculation would be this:\n\n[ ode ] \n\ndxdt_AUC = CENT/VC;\n\nif(SS_ADVANCE) dxdt_AUC = 0;\n\nThis code prevents the AUC compartment from changing during the advance to SS and the dose to dose difference in AUC will always be zero, effectively excluding this compartment from factoring into the SS determination. This should be the preferred approach to dealing with an AUC compartment."
  },
  {
    "objectID": "plugins.html#sec-plugin-autodec",
    "href": "plugins.html#sec-plugin-autodec",
    "title": "9  Plugins",
    "section": "9.1 autodec",
    "text": "9.1 autodec\nAvailable as of mrgsolve version 1.0.0.\nWhen this plugin is invoked, mrgsolve will search your model code for assignments and automatically declare them as double precision numbers. The following blocks are searched\n\n$PREAMBLE\n$MAIN (or $PK)\n$ODE (or $DES)\n$TABLE (or $ERROR)\n$PRED\n\nFor example, the following code requires that CL gets assigned a type\n\n$PARAM WT = 70, TVCL = 1.2\n\n$PK\ndouble CL = TVCL * pow(WT/70, 0.75);\n\nThis is the default mrgsolve behavior and has been since the beginning.\nThe autodec plugin lets you write the following\n\n$PLUGIN autodec \n\n$PARAM WT = 70, TVCL = 1.2\n\n$PK\nCL = TVCL * pow(WT/70, 0.75);\n\nmrgsolve will find CL = ... and understand that this is a user initiated variable and will declare it as double for you. Don’t worry about WT = 70 in $PARAM; mrgsolve should already know about that won’t try to declare it.\nWhen you are using the autodec plugin, you can still declare variables as double or int or bool. mrgsolve already finds those variables and will understand to leave those declarations alone. Note that it may still very convenient to declare using the capture type those variables that you want captured into the output\n\n$PLUGIN autodec\n\n$ERROR\ncapture Y = IPRED * exp(EPS(1));\n\nThe capture typedef makes Y a double; we didn’t need to declare it with autodec in play, but decided to declare with capture so that it is copied into the simulated output.\nThe autodec plugin is intended for more straightforward models where most / all variables are real valued. Because mrgsolve can handle any valid C++ code in these blocks, there is a possibility that the code could get much more complicated, including custom classes and methods. In this case, we recommend to bypass this feature and take control of declaring variables as you would in the default mode.\nIn case mrgsolve does try to declare (as double) a variable that shouldn’t be handled that way, you can note this name in an environment variable inside your model called MRGSOLVE_AUTODEC_SKIP\n\n$ENV MRGSOLVE_AUTODEC_SKIP = c(\"my_variable_1\")\n\nThis can be a vector of variable names to NOT declare when autodec is invoked."
  },
  {
    "objectID": "plugins.html#sec-plugin-nm-vars",
    "href": "plugins.html#sec-plugin-nm-vars",
    "title": "9  Plugins",
    "section": "9.2 nm-vars",
    "text": "9.2 nm-vars\nAvailable as of mrgsolve version 1.0.0.\nThe nm-vars plugin provides a more NONMEM-like set of macros to use when coding your compartmental model. Only a small subset of the NONMEM model syntax is replicated here.\nF, R, D, ALAG\n\nTo set bioavailability for the nth compartment, use Fn\nTo set the infusion rate for the nth compartment, use Rn\nTo set the infusion duration for the nth compartment, use Dn\nTo set the lag time for the nth compartment, use ALAGn\n\nFor example\n\n$CMT GUT CENT GUT2\n\n$PK\nF1 = 0.87;    // equivalent to F_GUT  = 0.87;\nR2 = 2.25;    // equivalent to R_CENT = 2.25;\nALAG3 = 0.25; // equivalent to ALAG_GUT2 = 0.25; \n\nA, A_0, DADT\n\nTo refer to the amount in the nth compartment, use A(n)\nTo refer to the initial amount in the nth compartment, use A_0(n)\nTo refer to the differential equation for the nth compartment, use DADT(n)\n\nFor example\n\n$CMT CMT1 CMT2\n\n$PK\nA_0(2) = 50;\n  \n$DES\nDADT(1) = -KA * A(1);\nDADT(2) =  KA * A(1) - KE * A(2); \n\nMath\nStarting with version 1.0.1, macros are provided for several math functions\n\nEXP(a) gets mapped to exp(a)\nLOG(a) gets mapped to log(a)\nSQRT(a) gets mapped to sqrt(a)\n\nThese are purely for convenience, so that upper-case versions from NMTRAN don’t require conversion to lower-case; this happens automatically via the C++ preprocessor.\nOther syntax\n\nUsing THETA(n) in model code will resolve to THETAn; this feature is always available, even when nm-vars hasn’t been invoked; we mention it here since it is a fundamental piece of the NONMEM syntax that mrgsolve has internalized\nUse T in $DES to refer to the current time in the odesolver rather than SOLVERTIME\n\nReserved words with nm-vars is invoked\nThere are some additional reserved words when the nm-vars plugin is invoked\n\nA\nA_0\nDADT\nT\n\nIt is an error to use one of these symbols as the name of a parameter or compartment or to try to declare them as variables.\nmrgsolve syntax that is still required\nThere are a lot of differences remaining between mrgsolve and NONMEM syntax. We mention a few here to make the point\n\nmrgsolve continues to require pow(base, exponent) rather than base**exponent\nmrgsolve continues to require a semi-colon at the end of each statement (this is a C++ requirement)\nmrgsolve continues to require that user-defined variables are declared with a type, except when the autodec plugin (Section 9.1) is invoked\n\nAn example\nThere is an example of this syntax (along with autodec features) in the internal model library\n\nmod <- modlib(\"nm-like\")\nsee(mod)\n\n\n\n. \n. Model file:  nm-like.cpp \n. $PROB Model written with some nonmem-like syntax features\n. \n. $PLUGIN nm-vars autodec\n. \n. $PARAM\n. THETA1 = 1, THETA2 = 21, THETA3 = 1.3, WT = 70, F1I = 0.5, D2I = 2\n. KIN = 100, KOUT = 0.1, IC50 = 10, IMAX = 0.9\n. \n. $CMT @number 3\n. \n. $PK\n. CL = THETA(1) * pow(WT/70, 0.75); \n. V  = THETA(2); \n. KA = THETA(3);\n. \n. F1 = F1I;\n. D2 = D2I;\n. A_0(3) = KIN / KOUT;\n. \n. $DES \n. CP = A(2)/V;\n. INH = IMAX*CP/(IC50 + CP);\n.   \n. DADT(1) = -KA*A(1);\n. DADT(2) =  KA*A(1) - (CL/V)*A(2);\n. DADT(3) =  KIN * (1-INH) - KOUT * A(3);\n. \n. $ERROR\n. CP = A(2)/V;"
  },
  {
    "objectID": "plugins.html#sec-plugin-tad",
    "href": "plugins.html#sec-plugin-tad",
    "title": "9  Plugins",
    "section": "9.3 tad",
    "text": "9.3 tad\nPurpose Advanced calculation time after dose within your model. We call this “advanced” because it lets you track doses in multiple compartments. See the note below about a simpler way to calculate time after dose that should work fine if doses are only in a single compartment. This functionality is provided by mrgsolve.\nUsage\nFirst, tell mrgsolve that you want to use the tad plugin\n\n$PLUGIN tad\n\nThe create tadose objects, one for each compartment where you want to track time after dose. One approach is to do this in [ global ]\n\n[plugin] tad\n\n[ global ] \nmrg::tadose tad_cmt_1(1); \nmrg::tadose tad_cmt_2(2);\n\nNotice that we pass the compartment number that we want to track in each case and also that we refer to the mrg:: namespace for the tadose class.\nThe tadose objects contain the following (public) members\n\ncmt the compartment to track\ntold the time of last dose; defaults to -1e9\nhad_dose indicates if a dose has already been given for the current individual\ntad(self) the function to call to calculate time after dose\n\nthe self object (Section 2.3.12) must be passed as the only argument\nwhen the member function is called prior to the first administered dose, a value of -1.0 is returned\n\nreset() resets the state of the object; be sure to reset prior to simulating a new individual\n\nAs an example, you can call the reset() method on one of the tadose objects\n\ntad_cmt_1.reset();\n\nYou can find the source code for this object here.\nA working example model that tracks doses in compartments 1 and 2 is provided here\n\n[plugin] tad\n\n[ global ] \nmrg::tadose tad_cmt_1(1); \nmrg::tadose tad_cmt_2(2);\n\n[ pkmodel ] cmt = \"GUT,CENT\", depot = TRUE\n\n[ param ] CL = 1, V = 20, KA = 1\n\n[ main ] \ncapture tad1 = tad_cmt_1.tad(self); \ncapture tad2 = tad_cmt_2.tad(self);\n\nStatic approach\nAnother approach would be to make these static in [ main ] but this approach would only work if you only use these in [ main ]; the [ global ] approach is preferable since then you can access the object in any block (function).\n\n9.3.1 Note\nNote there is a simpler way to calculate time after dose when only dosing into a single compartment\n\n[ main ]\ndouble tad = self.tad();\n\nThe self object (Section 2.3.21) contains a tad() member which will track time after dose. Note that this needs to be called every record."
  },
  {
    "objectID": "plugins.html#sec-plugin-cxx11",
    "href": "plugins.html#sec-plugin-cxx11",
    "title": "9  Plugins",
    "section": "9.4 CXX11",
    "text": "9.4 CXX11\nPurpose\nCompile your model file with C++11 standard.\nUsage\n\n$PLUGIN CXX11"
  },
  {
    "objectID": "plugins.html#sec-plugin-rcpp",
    "href": "plugins.html#sec-plugin-rcpp",
    "title": "9  Plugins",
    "section": "9.5 Rcpp",
    "text": "9.5 Rcpp\nPurpose\nLink to Rcpp headers into your model.\nUsage\n\n$PLUGIN Rcpp\n\nNote that once your model is linked to Rcpp, you can start using that functionality immediately (without including Rcpp.h).\nA very useful feature provided by Rcpp is that it exposes all of the dpqr functions that you normally use in R (e.g. rnorm() or runif()). So, if you want to simulate a number from Uniform (0,1) you can write\n\n$PLUGIN Rcpp\n\n$TABLE\ndouble uni = R::runif(0,1);\n\nNote that the arguments are the same as the R version (?runif) except there is no n argument; you always only get one draw.\nInformation about Rcpp can be found here: https://github.com/RcppCore/Rcpp"
  },
  {
    "objectID": "plugins.html#sec-plugin-mrgx",
    "href": "plugins.html#sec-plugin-mrgx",
    "title": "9  Plugins",
    "section": "9.6 mrgx",
    "text": "9.6 mrgx\nCompile in extra C++ / Rcpp functions that can be helpful to you for more advanced model coding. The mrgx plugin is dependent on the Rcpp plugin.\nThe functions provided by mrgx are in a namespace of the same name, so to invoke these functions, you always prepend mrgx::.\n\n9.6.1 Get the model environment\nNote that your model object (mod) contains an R environment. For example\n\nmrgsolve::house()@envir\n\n. <environment: 0x11689c630>\n\n\nThe objects in this environment are created by a block called $ENV in your model code (see Section 2.2.27);\nTo access this environment in your model, call\n\nRcpp::Environment env = mrgx::get_envir(self);"
  },
  {
    "objectID": "plugins.html#extract-an-object-from-the-model-environment",
    "href": "plugins.html#extract-an-object-from-the-model-environment",
    "title": "9  Plugins",
    "section": "9.7 Extract an object from the model environment",
    "text": "9.7 Extract an object from the model environment\nWhen you have an object created in $ENV\n\n[ env ] \nrand <- rnorm(100)\n\nYou can extract this object with\n\n[ preamble ]\nRcpp::NumericVector draw = mrgx::get(\"rand\", self);"
  },
  {
    "objectID": "plugins.html#rcpparmadillo",
    "href": "plugins.html#rcpparmadillo",
    "title": "9  Plugins",
    "section": "9.8 RcppArmadillo",
    "text": "9.8 RcppArmadillo\nPurpose\nLink to RcppArmadillo headers into your model.\nUsage\n\n$PLUGIN RcppArmadillo\n\nInformation about armadillo can be found here: http://arma.sourceforge.net/ Information about RcppArmadillo can be found here: https://github.com/RcppCore/RcppArmadillo"
  },
  {
    "objectID": "plugins.html#bh",
    "href": "plugins.html#bh",
    "title": "9  Plugins",
    "section": "9.9 BH",
    "text": "9.9 BH\nPurpose\nLink to boost headers into your model.\nUsage\n\n$PLUGIN BH\n\nNote that once your model is linked to BH (boost), you will be able to include the boost header file that you need. You have to include the header file that contains the boost function you want to use.\nInformation about boost can be found here: https://boost.org. Information about BH can be found here: https://github.com/eddelbuettel/bh"
  },
  {
    "objectID": "mtime.html#simple-mtime",
    "href": "mtime.html#simple-mtime",
    "title": "10  Modeled events",
    "section": "10.1 Simple MTIME",
    "text": "10.1 Simple MTIME\nUse this when you just want to introduce a non-dose discontinuity in your simulation at a specific time. For example, you want a parameter to change value at a specific time and you don’t know about the values or times prior to simulating.\nTo schedule a discontinuity, call the mtime() member (Section 2.3.22) of the self object (Section 2.3.12). This is typically done in the $MAIN block.\n\n[ main ]\ndouble mt = self.mtime(14.12);\n\nif(TIME >= mt) {\n  // do something  \n}\n\nHere, we have told mrgsolve to stop at 14.12 hours so we can do something. Notice that self.mtime() returns the value of the modeled even time so you can check it later.\nWe can also schedule an event to happen some amount of time in the future\n\n[ main ]\nif(NEWIND <= 1) {\n  double mt = 1e9;  \n}\n\nif(EVID==1) {\n  mt = self.mtime(TIME + 8.2);\n}\n\nif(TIME >= mt) {\n  // do something  \n}"
  },
  {
    "objectID": "mtime.html#mtime-with-specific-evid",
    "href": "mtime.html#mtime-with-specific-evid",
    "title": "10  Modeled events",
    "section": "10.2 MTIME with specific EVID",
    "text": "10.2 MTIME with specific EVID\nYou can call self.mevent() and pass both time and evid and then check for when that EVID comes around again. For example\n\nself.mevent(TIME + 8.2, 33);\n\nif(EVID==33) {\n  // do something  \n}\n\nThis is similar in functionality to self.mevent()."
  },
  {
    "objectID": "mtime.html#modeled-doses",
    "href": "mtime.html#modeled-doses",
    "title": "10  Modeled events",
    "section": "10.3 Modeled doses",
    "text": "10.3 Modeled doses\nThe previous examples showed you how to get the simulation to stop so you can do something in $MAIN. In this section, we show you how to schedule doses in a similar way. This will take some extra coding and will also serve to uncover how self.mtime() and self.mevent() work.\nYou can set up the following code in either $MAIN or $TABLE.\nCreate an evdata object\nOnce you know when you want the dose, create an evdata object.\n\nmrg::evdata ev(14.2, 1);\n\nThis will create (construct) an object called ev with class evdata. The constructor takes two arguments:\n\nthe TIME the event should happen\nthe EVID for the event\n\nThis is the only available constructor for evdata objects. You can browse the source code for the evdata object here.\nModify the evdata object Once the object is created, you can modify the following public members\n\ntime: the event time (double)\nevid: the event ID (int)\namt: the dose amount (double)\ncmt: the compartment number (int)\nrate: the rate to infuse amt (double)\nnow: should the dose be given immediately? (bool)\n\nIf you are using this (lower-level) interface, chances are you will want to set at least amt and cmt. As an example, we will dose 100 mg into compartment 2 immediately (now)\n\nev.amt = 100;\nev.cmt = 2;\nev.now = true;\n\nThe other members are set in a similar way.\nPush the evdata object into the self object\nAfter the object has been created and modified, you have to attach this object to the self object in order to make it available to mrgsolve. Do this by calling push_back() on self.mevector\n\nself.mevector.push_back(ev);\n\nAgain, this sequence should get called in either $MAIN or $TABLE. When that code block finishes running (for the current record), mrgsolve will find the event record and add that event to the simulation sequence."
  },
  {
    "objectID": "topics.html#sec-topic-annotated",
    "href": "topics.html#sec-topic-annotated",
    "title": "11  Topics",
    "section": "11.1 Annotated model specification",
    "text": "11.1 Annotated model specification\nHere is a complete annotated mrgsolve model. The goal was to get in several of the most common blocks that you might want to annotate. The different code blocks are rendered here separately for clarity in presentation; but users should include all relevant blocks in a single file (or R string).\n\n$PROB\n\n# Final PK model\n\n- Author: Pmetrics Scientist\n- Client: Pharmaco, Inc.\n- Date: `r Sys.Date()`\n- NONMEM Run: 12345\n- Structure: one compartment, first order absorption\n- Implementation: closed form solutions\n- Error model: Additive + proportional\n- Covariates:\n  - WT on clearance\n- SEX on volume\n- Random effects on: `CL`, `V`, `KA`\n\n\n[PARAM] @annotated\nTVCL : 1.1   : Clearance (L/hr)\nTVV  : 35.6  : Volume of distribution (L)\nTVKA : 1.35  : Absorption rate constant (1/hr)\nWT   : 70    : Weight (kg)\nSEX  : 1     : Male = 0, Female 1\nWTCL : 0.75  : Exponent weight on CL\nSEXV : 0.878 : Volume female/Volume male\n\n\n[MAIN]\ndouble CL = TVCL*pow(WT/70,WTCL)*exp(ECL);\ndouble V  = TVV *pow(SEXVC,SEX)*exp(EV);\ndouble KA = TVKA*exp(EKA);\n\n\n[OMEGA] @name OMGA @correlation @block @annotated\nECL : 1.23 : Random effect on CL\nEV  : 0.67 0.4 : Random effect on V\nEKA : 0.25 0.87 0.2 : Random effect on KA\n\n\n[SIGMA] @name SGMA @annotated\nPROP: 0.25 : Proportional residual error\nADD : 25   : Additive residual error\n\n\n[CMT] @annotated\nGUT  : Dosing compartment  (mg)\nCENT : Central compartment (mg)\n\n\n[PKMODEL] ncmt = 1, depot=TRUE\n\n\n[TABLE]\ncapture IPRED = CENT/V;\ndouble DV = IPRED*(1+PROP) + ADD;\n\n\n[CAPTURE] @annotated\nDV  : Concentration (mg/L)\nECL : Random effect on CL\nCL  : Individual clearance (L/hr)"
  },
  {
    "objectID": "topics.html#sec-topic-init",
    "href": "topics.html#sec-topic-init",
    "title": "11  Topics",
    "section": "11.2 Set initial conditions",
    "text": "11.2 Set initial conditions\n\nlibrary(mrgsolve)\nlibrary(dplyr)\n\n\n\n\n\n11.2.1 Summary\n\nmrgsolve keeps a base list of compartments and initial conditions that you can update either from R or from inside the model specification\nWhen you use $CMT, the value in that base list is assumed to be 0 for every compartment\nmrgsolve will by default use the values in that base list when starting the problem\nWhen only the base list is available, every individual will get the same initial condition\nYou can override this base list by including code in $MAIN to set the initial condition\nMost often, you do this so that the initial is calculated as a function of a parameter\nFor example, $MAIN RESP_0 = KIN/KOUT; when KIN and KOUT have some value in $PARAM\nThis code in $MAIN overwrites the value in the base list for the current ID\nFor typical PK/PD type models, we most frequently initialize in $MAIN\nThis is equivalent to what you might do in your NONMEM model\nFor larger systems models, we often just set the initial value via the base list\n\n\n\n11.2.2 Make a model only to examine init behavior\nNote: IFLAG is my invention only for this demo. The demo is always responsible for setting and interpreting the value (it is not reserved in any way and mrgsolve does not control the value).\nFor this demo\n\nCompartment A initial condition defaults to 0\nCompartment A initial condition will get set to BASE only if IFLAG  > 0\nCompartment A always stays at the initial condition\n\n\ncode <- '\n$PARAM BASE=100, IFLAG = 0\n\n$CMT A\n\n$MAIN\n\nif(IFLAG > 0) A_0 = BASE;\n\n$ODE dxdt_A = 0;\n'\n\n\nmod <- mcode(\"init\",code)\n\nCheck the initial condition\n\ninit(mod)\n\n. \n.  Model initial conditions (N=1):\n.  name    value . name    value\n.  A (1)   0     | . ...   .\n\n\nNote:\n\nWe used $CMT in the model spec; that implies that the base initial condition for A is set to 0\nIn this chunk, the code in $MAIN doesn’t get run because IFLAG is 0\nSo, if we don’t update something in $MAIN the initial condition is as we set it in the base list\n\n\nmod %>% mrgsim() %>% plot()\n\n\n\n\nNext, we update the base initial condition for A to 50\nNote:\n\nThe code in $MAIN still doesn’t get run because IFLAG is 0\n\n\nmod %>% init(A = 50) %>% mrgsim() %>% plot()\n\n\n\n\nNow, turn on IFLAG\nNote:\n\nNow, that code in $MAIN gets run\nA_0 is set to the value of BASE\n\n\nmod %>% param(IFLAG=1) %>% mrgsim() %>% plot()\n\n\n\n\n\nmod %>% param(IFLAG=1, BASE=300) %>% mrgsim() %>% plot()\n\n\n\n\n\n\n11.2.3 Example PK/PD model with initial condition\nJust to be clear, there is no need to set any sort of flag to set the initial condition as seen here:\n\ncode <- '\n$PARAM AUC=0, AUC50 = 75, KIN=200, KOUT=5\n\n$CMT RESP\n\n$MAIN \nRESP_0 = KIN/KOUT;\n\n$ODE\n\ndxdt_RESP = KIN*(1-AUC/(AUC50+AUC)) - KOUT*RESP;\n\n'\n\n\nmod <- mcode(\"init2\", code)\n\nThe initial condition is set to 40 per the values of KIN and KOUT\n\nmod %>% mrgsim() %>% plot()\n\n\n\n\nEven when we change RESP_0 in R, the calculation in $MAIN gets the final say\n\nmod %>% init(RESP=1E9) %>% mrgsim()\n\n. Model:  init2 \n. Dim:    25 x 3 \n. Time:   0 to 24 \n. ID:     1 \n.     ID time RESP\n. 1:   1    0   40\n. 2:   1    1   40\n. 3:   1    2   40\n. 4:   1    3   40\n. 5:   1    4   40\n. 6:   1    5   40\n. 7:   1    6   40\n. 8:   1    7   40\n\n\n\n\n11.2.4 Remember: calling init will let you check to see what is going on\n\nIt’s a good idea to get in the habit of doing this when things aren’t clear\ninit first takes the base initial condition list, then calls $MAIN and does any calculation you have in there; so the result is the calculated initials\n\n\ninit(mod)\n\n. \n.  Model initial conditions (N=1):\n.  name       value . name    value\n.  RESP (1)   40    | . ...   .\n\n\n\nmod %>% param(KIN=100) %>% init()\n\n. \n.  Model initial conditions (N=1):\n.  name       value . name    value\n.  RESP (1)   20    | . ...   .\n\n\n\n\n11.2.5 Set initial conditions via idata\nGo back to house model\n\nmod <- house()\n\n\ninit(mod)\n\n. \n.  Model initial conditions (N=3):\n.  name       value . name       value\n.  CENT (2)   0     | RESP (3)   50   \n.  GUT (1)    0     | . ...      .\n\n\nNotes\n\nIn idata (only), include a column with CMT_0 (like you’d do in $MAIN).\nWhen each ID is simulated, the idata value will override the base initial list for that subject.\nBut note that if CMT_0 is set in $MAIN, that will override the idata update.\n\n\nidata <- expand.idata(CENT_0 = seq(0,25,1))\n\n\nidata %>% head()\n\n.   ID CENT_0\n. 1  1      0\n. 2  2      1\n. 3  3      2\n. 4  4      3\n. 5  5      4\n. 6  6      5\n\n\n\nout <- \n  mod %>% \n  idata_set(idata) %>% \n  mrgsim(end=40)\n\n\nplot(out, CENT~.)"
  },
  {
    "objectID": "topics.html#sec-topic-parameter-update",
    "href": "topics.html#sec-topic-parameter-update",
    "title": "11  Topics",
    "section": "11.3 Updating parameters",
    "text": "11.3 Updating parameters\nThe parameter list was introduced in Section 1.1 and the $PARAM code block was shown in Section 2.2.4. Once a model is compiled, the names and number of parameters in a model is fixed. However, the values of parameters can be changed: parameters may be updated either by the user (in R) or by mrgsolve (in the C++ simulation engine, as the simulation proceeds).\n\nTo update in R, use the param() function (see examples below)\nTo have mrgsolve update the parameters, attach columns to your data set (either data_set or idata_set) with the same name as items in the parameter list\n\nBoth of these methods are discussed and illustrated in the following sections.\n\n11.3.1 Parameter update hierarchy\nAs we noted above, new parameter values can come from three potential sources:\n\nModification of the (base) parameter list\nA column in an idata_set that has the same name as a model parameter\nA column in a data_set that has the same name as a model parameter\n\nThese sources for new parameter values are discussed below. We note here that the sources listed above are listed in the order of the parameter update hierarchy. So, the base parameter list provides the value by default. A parameter value coming from an idata_set will override the value in the base list. And a parameter value coming from a data_set will override the value coming from the base list or an idata_set (in case a parameter is listed in both the idata_set and the data_set). In other words, the hierarchy is:\n\nbase parameter list is the default\nthe idata_set overrides the base list\nthe data_set overrides the idata_set and the base list\n\nThe parameter update hierarchy is discussed in the following sections.\nBase parameter set\n\nEvery model has a base set of “parameters”\nThese are named and set in $PARAM\nParameters can only get into the parameter list in $PARAM (or $THETA)\nNo changing the names or numbers of parameters once the model is compiled\nBut, several ways to change the values\n\n\ncode <- '\n$VCMT KYLE\n$PARAM CL = 1.1, VC=23.1, KA=1.7, KM=10\n$CAPTURE CL VC KA KM\n'\nmod <- mcode(\"tmp\", code, warn=FALSE)\n\n\nparam(mod)\n\n. \n.  Model parameters (N=4):\n.  name value . name value\n.  CL   1.1   | KM   10   \n.  KA   1.7   | VC   23.1\n\n\nThe base parameter set is the default\nThe base parameter set allows you to run the model without entering any other data; there are some default values in place.\nThe parameters in the base list can be changed or updated in R\nUse the param() function to both set and get:\n\nmod <-  param(mod, CL=2.1)\n\n\nparam(mod)\n\n. \n.  Model parameters (N=4):\n.  name value . name value\n.  CL   2.1   | KM   10   \n.  KA   1.7   | VC   23.1\n\n\nBut whatever you’ve done in R, there is a base set (with values) to use. See Section 11.3.2 for a more detailed discussion of using param() to updated the base list.\nParameters can also be updated during the simulation run\nParameters can be updated by putting columns in idata set or data_set that have the same name as one of the parameters in the parameter list. But there is no changing values in the base parameter set once the simulation starts.\nThat is, the following model specification will not compile:\n\n$PARAM CL = 2\n\n$MAIN CL = 3; // ERROR\n\nYou cannot over-write the value of a parameter in the model specification.\nLet mrgsolve do the updating.\nmrgsolve always reverts to the base parameter set when starting work on a new individual.\nParameters updated from idata_set\nWhen mrgsolve finds parameters in idata, it will update the base parameter list with those parameters prior to starting that individual.\n\ndata(exidata)\nhead(exidata)\n\n.   ID    CL    VC     KA KOUT  IC50 FOO\n. 1  1 1.050 47.80 0.8390 2.45 1.280   4\n. 2  2 0.730 30.10 0.0684 2.51 1.840   6\n. 3  3 2.820 23.80 0.1180 3.88 2.480   5\n. 4  4 0.552 26.30 0.4950 1.18 0.977   2\n. 5  5 0.483  4.36 0.1220 2.35 0.483  10\n. 6  6 3.620 39.80 0.1260 1.89 4.240   1\n\n\nNotice that there are several columns in exidata that match up with the names in the parameter list\n\nnames(exidata)\n\n. [1] \"ID\"   \"CL\"   \"VC\"   \"KA\"   \"KOUT\" \"IC50\" \"FOO\"\n\nnames(param(mod))\n\n. [1] \"CL\" \"VC\" \"KA\" \"KM\"\n\n\nThe matching names tell mrgsolve to update, assigning each individual their individual parameter.\n\nout <- \n  mod %>%\n  idata_set(exidata) %>%\n  mrgsim(end=-1 , add=c(0,2))\n\n\nout\n\n. Model:  tmp \n. Dim:    20 x 7 \n. Time:   0 to 2 \n. ID:     10 \n.     ID time KYLE    CL   VC     KA KM\n. 1:   1    0    0 1.050 47.8 0.8390 10\n. 2:   1    2    0 1.050 47.8 0.8390 10\n. 3:   2    0    0 0.730 30.1 0.0684 10\n. 4:   2    2    0 0.730 30.1 0.0684 10\n. 5:   3    0    0 2.820 23.8 0.1180 10\n. 6:   3    2    0 2.820 23.8 0.1180 10\n. 7:   4    0    0 0.552 26.3 0.4950 10\n. 8:   4    2    0 0.552 26.3 0.4950 10\n\n\nParameters updated from data_set\nLike an idata set, we can put parameters on a data set\n\ndata <- expand.ev(amt=0, CL=c(1,2,3), VC=30)\n\n\nout <- \n  mod %>%\n  data_set(data) %>% \n  obsonly %>%\n  mrgsim(end=-1, add=c(0,2))\n\n\nout\n\n. Model:  tmp \n. Dim:    6 x 7 \n. Time:   0 to 2 \n. ID:     3 \n.     ID time KYLE CL VC  KA KM\n. 1:   1    0    0  1 30 1.7 10\n. 2:   1    2    0  1 30 1.7 10\n. 3:   2    0    0  2 30 1.7 10\n. 4:   2    2    0  2 30 1.7 10\n. 5:   3    0    0  3 30 1.7 10\n. 6:   3    2    0  3 30 1.7 10\n\n\nThis is how we do time-varying parameters:\n\ndata <- \n  data_frame(CL=seq(1,5)) %>%\n  mutate(evid=0,ID=1,cmt=1,time=CL-1,amt=0)\n\n. Warning: `data_frame()` was deprecated in tibble 1.1.0.\n. ℹ Please use `tibble()` instead.\n\n\n\nmod %>%\n  data_set(data) %>%\n  mrgsim(end=-1)\n\n. Model:  tmp \n. Dim:    5 x 7 \n. Time:   0 to 4 \n. ID:     1 \n.     ID time KYLE CL   VC  KA KM\n. 1:   1    0    0  1 23.1 1.7 10\n. 2:   1    1    0  2 23.1 1.7 10\n. 3:   1    2    0  3 23.1 1.7 10\n. 4:   1    3    0  4 23.1 1.7 10\n. 5:   1    4    0  5 23.1 1.7 10\n\n\nFor more information on time-varying covariates (parameters), see Section 11.8 and Chapter 7.\nParameters are carried back when first record isn’t at time == 0\nWhat about this?\n\ndata <- expand.ev(amt=100,time=24,CL=5,VC=32)\ndata\n\n.   ID time amt cmt evid CL VC\n. 1  1   24 100   1    1  5 32\n\n\nThe first data record happens at time==24\n\nmod %>% \n  data_set(data) %>%\n  mrgsim(end=-1, add=c(0,2))\n\n. Model:  tmp \n. Dim:    3 x 7 \n. Time:   0 to 24 \n. ID:     1 \n.     ID time KYLE CL VC  KA KM\n. 1:   1    0    0  5 32 1.7 10\n. 2:   1    2    0  5 32 1.7 10\n. 3:   1   24  100  5 32 1.7 10\n\n\nSince the data set doesn’t start until time==5, we might think that CL doesn’t change from the base parameter set until then.\nBut by default, mrgsolve carries those parameter values back to the start of the simulation. This is by design … by far the more useful configuration.\nIf you wanted the base parameter set in play until that first data set record, do this:\n\nmod %>%\n  data_set(data) %>%\n  mrgsim(end=-1,add=c(0,2), filbak=FALSE)\n\n. Model:  tmp \n. Dim:    3 x 7 \n. Time:   0 to 24 \n. ID:     1 \n.     ID time KYLE CL VC  KA KM\n. 1:   1    0    0  5 32 1.7 10\n. 2:   1    2    0  5 32 1.7 10\n. 3:   1   24  100  5 32 1.7 10\n\n\nWill this work?\n\nidata <- do.call(\"expand.idata\", as.list(param(mod)))\n\nidata\n\n.   ID  CL   VC  KA KM\n. 1  1 2.1 23.1 1.7 10\n\n\nHere, we’ll pass in both data_set and idata_set and they have conflicting values for the parameters.\n\nmod %>%\n  data_set(data) %>%\n  idata_set(idata) %>%\n  mrgsim(end=-1,add=c(0,2))\n\n. Model:  tmp \n. Dim:    3 x 7 \n. Time:   0 to 24 \n. ID:     1 \n.     ID time KYLE CL VC  KA KM\n. 1:   1    0    0  5 32 1.7 10\n. 2:   1    2    0  5 32 1.7 10\n. 3:   1   24  100  5 32 1.7 10\n\n\nThe data set always gets the last word.\n\n\n11.3.2 Updating the base parameter list\nFrom the previous section\n\nparam(mod)\n\n. \n.  Model parameters (N=4):\n.  name value . name value\n.  CL   2.1   | KM   10   \n.  KA   1.7   | VC   23.1\n\n\nUpdate with name-value pairs\nWe can call param() to update the model object, directly naming the parameter to update and the new value to take\n\nmod %>% param(CL = 777, KM = 999) %>% param\n\n. \n.  Model parameters (N=4):\n.  name value . name value\n.  CL   777   | KM   999  \n.  KA   1.7   | VC   23.1\n\n\nThe parameter list can also be updated by scanning the names in a list\n\nwhat <- list(CL = 555, VC = 888, KYLE = 123, MN = 100)\n\nmod %>% param(what) %>% param\n\n. \n.  Model parameters (N=4):\n.  name value . name value\n.  CL   555   | KM   10   \n.  KA   1.7   | VC   888\n\n\nmrgsolve looks at the names to drive the update. KYLE (a compartment name) and MN (not in the model anywhere) are ignored.\nAlternatively, we can pick a row from a data frame to provide the input for the update\n\nd <- data_frame(CL=c(9,10), VC=c(11,12), KTB=c(13,14))\n\nmod %>% param(d[2,]) %>% param\n\n. \n.  Model parameters (N=4):\n.  name value . name value\n.  CL   10    | KM   10   \n.  KA   1.7   | VC   12\n\n\nHere the second row in the data frame drives the update. Other names are ignored.\nA warning will be issued if an update is attempted, but no matching names are found\n\nmod %>% param(ZIP = 1, CODE = 2) %>% param\n\nWarning message:\nFound nothing to update: param"
  },
  {
    "objectID": "topics.html#sec-topic-tgrid",
    "href": "topics.html#sec-topic-tgrid",
    "title": "11  Topics",
    "section": "11.4 Time grid objects",
    "text": "11.4 Time grid objects\nSimulation times in mrgsolve\n\nmod <- mrgsolve:::house() %>% Req(CP) %>% ev(amt = 1000, ii = 24, addl = 1000) \n\nmrgsolve keeps track of a simulation start and end time and a fixed size step between start and end (called delta). mrgsolve also keeps an arbitrary vector of simulation times called add.\n\nmod %>%\n  mrgsim(end = 4, delta = 2, add = c(7,9,50)) %>%\n  as.data.frame()\n\n.   ID time       CP\n. 1  1    0  0.00000\n. 2  1    0  0.00000\n. 3  1    2 42.47580\n. 4  1    4 42.28701\n. 5  1    7 36.75460\n. 6  1    9 33.26649\n. 7  1   50 60.97754\n\n\ntgrid objects\nThe tgrid object abstracts this setup and allows us to make complicated sampling designs from elementary building blocks.\nMake a day 1 sampling with intensive sampling around the peak and sparser otherwise\n\npeak1 <- tgrid(1, 4, 0.1)\nsparse1 <- tgrid(0, 24, 4)\n\nUse the c operator to combine simpler designs into more complicated designs\n\nday1 <- c(peak1, sparse1)\n\nCheck this by calling stime\n\nstime(day1)\n\n.  [1]  0.0  1.0  1.1  1.2  1.3  1.4  1.5  1.6  1.7  1.8  1.9  2.0  2.1  2.2  2.3\n. [16]  2.4  2.5  2.6  2.7  2.8  2.9  3.0  3.1  3.2  3.3  3.4  3.5  3.6  3.7  3.8\n. [31]  3.9  4.0  8.0 12.0 16.0 20.0 24.0\n\n\nPass this object in to mrgsim as tgrid. It will override the default start/end/delta/add sequence.\n\nmod %>% \n  mrgsim(tgrid = day1) %>%\n  plot(type = 'b')\n\n\n\n\nNow, look at both day 1 and day 10:\nAdding a number to a tgrid object will offset those times by that amount.\n\ndes <- c(day1, day1 + 10*24)\n\nmod %>% \n  mrgsim(tgrid = des) %>%\n  plot(type = 'b')\n\n\n\n\nPick up day 5 as well\n\ndes <- c(des, day1 + 5*24)\n\nmod %>% \n  mrgsim(tgrid = des) %>%\n  plot(type = 'b')"
  },
  {
    "objectID": "topics.html#sec-topic-designs",
    "href": "topics.html#sec-topic-designs",
    "title": "11  Topics",
    "section": "11.5 Individualized sampling designs",
    "text": "11.5 Individualized sampling designs\nHere is a PopPK model and a full data_set.\n\nmod <- house()\n\ndata(exTheoph)\n\ndf <- exTheoph\n\nhead(df)\n\n.   ID   WT Dose time  conc cmt  amt evid\n. 1  1 79.6 4.02 0.00  0.00   1 4.02    1\n. 2  1 79.6 4.02 0.25  2.84   0 0.00    0\n. 3  1 79.6 4.02 0.57  6.57   0 0.00    0\n. 4  1 79.6 4.02 1.12 10.50   0 0.00    0\n. 5  1 79.6 4.02 2.02  9.66   0 0.00    0\n. 6  1 79.6 4.02 3.82  8.58   0 0.00    0\n\n\n\nmod %>% \n  Req(CP) %>%\n  carry.out(a.u.g) %>%\n  data_set(df) %>%\n  obsaug() %>%\n  mrgsim() \n\n. Model:  housemodel \n. Dim:    5904 x 4 \n. Time:   0 to 120 \n. ID:     12 \n.     ID time a.u.g      CP\n. 1:   1 0.00     1 0.00000\n. 2:   1 0.00     0 0.00000\n. 3:   1 0.25     1 0.04552\n. 4:   1 0.25     0 0.04552\n. 5:   1 0.50     1 0.07870\n. 6:   1 0.57     0 0.08624\n. 7:   1 0.75     1 0.10274\n. 8:   1 1.00     1 0.12001\n\n\nNow, define two time grid objects: des1 runs from 0 to 24 and des2 runs from 0 to 96, both every hour.\n\ndes1 <- tgrid(0, 24, 1)\ndes2 <- tgrid(0, 96, 1)\n\nrange(stime(des1))\n\n. [1]  0 24\n\nrange(stime(des2))\n\n. [1]  0 96\n\n\nNow, derive an idata_set after adding a grouping column (GRP) that splits the data set into two groups\n\ndf <-  mutate(df, GRP = as.integer(ID > 5))\n\nid <- distinct(df, ID, GRP) \n\nid\n\n.    ID GRP\n. 1   1   0\n. 2   2   0\n. 3   3   0\n. 4   4   0\n. 5   5   0\n. 6   6   1\n. 7   7   1\n. 8   8   1\n. 9   9   1\n. 10 10   1\n. 11 11   1\n. 12 12   1\n\n\nNow, we have two groups in GRP in idata_set and we have two tgrid objects.\n\nPass in both the idata_set and the data_set\nCall design\nIdentify GRP as descol; the column must be in idata_set\nPass in a list of designs; it must be at least two because there are two levels in GRP\n\nWhen we simulate, the individuals in GRP 1 will get des1 and those in GRP 2 will get des2\n\nout <- \n  mod %>% \n  Req(CP) %>%\n  carry.out(a.u.g,GRP) %>%\n  idata_set(id) %>%\n  data_set(df) %>%\n  design(descol = \"GRP\", deslist = list(des1, des2)) %>%\n  obsaug() %>%\n  mrgsim() \n\nplot(out, CP~time|GRP)"
  },
  {
    "objectID": "topics.html#some-helpful-c",
    "href": "topics.html#some-helpful-c",
    "title": "11  Topics",
    "section": "11.6 Some helpful C++",
    "text": "11.6 Some helpful C++\nRecall that the following blocks require valid C++ code:\n\n$PREAMBLE\n$MAIN\n$ODE\n$TABLE\n$GLOBAL\n$PRED\n\nWe don’t want users to have to be proficient in C++ to be able to use mrgsolve. and we’ve created several macros to help simplify things as much as possible.\nHowever, it is required to become familiar with some of the basics and certainly additional knowledge of how to do more than just the basics will help you code more and more complicated models in mrgsolve.\nThere are an unending stream of tutorials, references and help pages on C++ to be found on the interweb. As a general source, I like to use https://en.cppreference.com/. But, again, there many other good resources out there that can suit your needs.\nThe rest of this section provides a very general reference of the types of C++ code and functions that you might be using in your model.\n\n11.6.1 Semi-colons\nEvery statement in C++ must end with a semi-colon. For example;\n\n[ MAIN ] \ndouble CL = exp(log_TVCL + ETA(1));\n\nor\n\n[ ODE ] \n\ndxdt_DEPOT = -KA * DEPOT;\n\n\n\n11.6.2 if-else\n\nif(a == 2) b = 2;\n\n\nif(a==2) {\n  b = 2;  \n}\n\n\nif(a == 2) {\n  b=2;\n} else {\n  b=3;\n}\n\nThis is the equivalent of x <- ifelse(c == 4, 8, 10) in R\n\ndouble x = c == 4 ? 8 : 10;\n\n\n\n11.6.3 Functions\nThe following functions are hopefully understandable based on the function name. Consult https://cppreference.com for further details.\n\n# base^exponent\ndouble d = pow(base,exponent);\n\ndouble e = exp(3);\n\n# absolute value\ndouble f = fabs(-4);\n\ndouble g = sqrt(5);\n\ndouble h = log(6);\n\ndouble i = log10(7);\n\ndouble j = floor(4.2);\n\ndouble k = ceil(4.2);\n\ndouble l = std::max(0.0, -3.0);\n\ndouble m = std::min(0.0, -3.0);\n\n\n\n11.6.4 Integer division\nThe user is warned about division with two integers. In R, the following statement evaluates to 0.75:\n\n3/4\n\n. [1] 0.75\n\n\nBut in C++ it evaluates to 0:\n\ndouble x = 3/4;\n\nThis is because both the 3 and the 4 are taken as integer literals. This produces the same result as\n\nint a = 3;\nint b = 4;\ndouble x = a/b;\n\nWhen one integer is divided by another integer, the remainder is discarded (the result is rounded down). This is the way C++ works. The user is warned.\nNote that parameters in mrgsolve are doubles so this will evaluate to 0.75\n\n[ PARAM ] a = 3\n\n[ MAIN ] \ndouble x = a/4;\n\nSince a is a parameter the operation of a/4 is not integer division and the result is 0.75.\nUnless you are already very comfortable with this concept, users are encouraged to add .0 suffix to any literal number written as C++ code. For example:\n\ndouble x = 3.0 / 4.0;\n\nI think it’s fair to say that the vast majority of time you want this to evaluate to 0.75 and writing 3.0/4.0 rather than 3/4 will ensure you will not discard any remainder here.\nIf you would like to experiment with these concepts, try running this code\n\nlibrary(mrgsolve)\n\ncode <- '\n[ param ] a = 3\n\n[ main ] \ncapture x = 3/4;\ncapture y = 3.0/4.0;\ncapture z = a/4;\n'\nmod <- mcode(\"foo\", code)\n\nmrgsim(mod)\n\n. Model:  foo \n. Dim:    25 x 5 \n. Time:   0 to 24 \n. ID:     1 \n.     ID time x    y    z\n. 1:   1    0 0 0.75 0.75\n. 2:   1    1 0 0.75 0.75\n. 3:   1    2 0 0.75 0.75\n. 4:   1    3 0 0.75 0.75\n. 5:   1    4 0 0.75 0.75\n. 6:   1    5 0 0.75 0.75\n. 7:   1    6 0 0.75 0.75\n. 8:   1    7 0 0.75 0.75\n\n\n\n\n11.6.5 Pre-processor directives\nPre-processor directives are global substitutions that are made in your model code at the time the model is compiled. For example\n\n$GLOBAL \n\n#define CP (CENT/VC)\n\nWhen you write this into your model, the pre-processor will find every instance of CP and replace it with (CENT/VC). This substitution happens right as the model is compiled; you won’t see this substitution happen anywhere, but think of it as literal replacement of CP with (CENT/VC).\nNote:\n\nPut all pre-processor directives in $GLOBAL.\nIt is usually a good idea to enclose the substituted coded in parentheses; this ensures that, for example, CENT/VC is evaluated as is, regardless of the surrounding code where it is evaluated.\nUnder the hood, mrgsolve uses lots of pre-processor directives to define parameter names, compartment names and other variables; you will see a compiler error if you try to re-define an existing pre-processor directive. If so, just choose another name for your directive."
  },
  {
    "objectID": "topics.html#resimulate-eta-and-eps",
    "href": "topics.html#resimulate-eta-and-eps",
    "title": "11  Topics",
    "section": "11.7 Resimulate ETA and EPS",
    "text": "11.7 Resimulate ETA and EPS\nCall simeta() to resimulate ETA\n\nNo $PLUGIN is required\nsimeta() takes no arguments; all ETA values are resimulated\n\nFor example, we can simulate individual-level covariates within a certain range:\n\ncode <- '\n$PARAM TVCL = 1, TVWT = 70\n\n$MAIN \ncapture WT = TVWT*exp(EWT);\n\nint i = 0;\n\nwhile((WT < 60) || (WT > 80)) {\n  if(++i > 100) break;\n  simeta();\n  WT = TVWT*exp(EWT);\n}\n\n$OMEGA @labels EWT\n4\n\n$CAPTURE EWT WT\n'\n\nmod <- mcode(\"simeta\", code)\n\nout <- mod %>% mrgsim(nid=100, end=-1)\n\nsum <- summary(out)\n\nsum\n\n.        ID              time        EWT                  WT       \n.  Min.   :  1.00   Min.   :0   Min.   :-0.152052   Min.   :60.13  \n.  1st Qu.: 25.75   1st Qu.:0   1st Qu.:-0.084192   1st Qu.:64.35  \n.  Median : 50.50   Median :0   Median : 0.002724   Median :70.19  \n.  Mean   : 50.50   Mean   :0   Mean   :-0.008335   Mean   :69.68  \n.  3rd Qu.: 75.25   3rd Qu.:0   3rd Qu.: 0.059169   3rd Qu.:74.27  \n.  Max.   :100.00   Max.   :0   Max.   : 0.133370   Max.   :79.99\n\n\nCall simeps() to resimulate EPS\n\nNo $PLUGIN is required\nsimeps() takes no arguments; all EPS values are resimulated\n\nFor example, we can resimulate until all concentrations are greater than zero:\n\ncode <- '\n$PARAM CL = 1, V = 20,\n\n$CMT CENT\n\n$SIGMA 50\n\n$PKMODEL ncmt=1\n\n$TABLE\ncapture CP = CENT/V + EPS(1);\n\nint i = 0;\n\nwhile(CP < 0 && i < 100) {\n  simeps();\n  CP = CENT/V + EPS(1);\n  ++i;\n}\n\n'\n\nmod <- mcode(\"simeps\", code)\n\nout <- mod %>% ev(amt=100) %>% mrgsim(end=48)\nsum <- summary(out)\n\nsum\n\n.        ID         time            CENT              CP         \n.  Min.   :1   Min.   : 0.00   Min.   :  0.00   Min.   : 0.3681  \n.  1st Qu.:1   1st Qu.:11.25   1st Qu.: 15.93   1st Qu.: 2.8067  \n.  Median :1   Median :23.50   Median : 29.38   Median : 4.5036  \n.  Mean   :1   Mean   :23.52   Mean   : 37.47   Mean   : 5.7805  \n.  3rd Qu.:1   3rd Qu.:35.75   3rd Qu.: 54.21   3rd Qu.: 8.8972  \n.  Max.   :1   Max.   :48.00   Max.   :100.00   Max.   :15.3570\n\n\nA safety check is recommended Note that in both examples, we implement a safety check: an integer counter is incremented every time we resimulated. The resimulation process stops if we don’t reach the desired condition within 100 replicates. You might also consider issuing a message or a flag in the simulated data if you are not able to reach the desired condition."
  },
  {
    "objectID": "topics.html#sec-topics-time-varying",
    "href": "topics.html#sec-topics-time-varying",
    "title": "11  Topics",
    "section": "11.8 Time varying covariates",
    "text": "11.8 Time varying covariates\nA note in a previous section showed how to implement time-varying covariates or other time-varying parameters by including those parameters as column in the data set.\nBy default, mrgsolve performs next observation carried backward (nocb) when processing time-varying covariates. That is, when the system advances from TIME1 to TIME2, and the advance is a function of a covariate found in the data set, the system advances using the covariate value COV2 rather than the covariate COV1.\nThe user can change the behavior to last observation carried forward (locf), so that the system uses the value of COV1 to advance from TIME1 to TIME2. To use locf advance, set nocb to FALSE when calling mrgsim. For example,\n\nmod %>% mrgsim(nocb = FALSE)\n\nThere is additional information about the sequence of events that takes place during system advance in Chapter 7."
  },
  {
    "objectID": "q-and-a.html#can-i-interrupt-a-simulation",
    "href": "q-and-a.html#can-i-interrupt-a-simulation",
    "title": "12  Questions and Answers",
    "section": "12.1 Can I interrupt a simulation?",
    "text": "12.1 Can I interrupt a simulation?\nStarting with mrgsolve version 0.11.1, you can interrupt a long simulation by pressing Control-C or Esc, the standard way to pass an interrupt signal through R. mrgsolve will stop every so often to look for the interrupt signal.\nYou can control the frequency with which mrgsolve looks for the interrupt signal through an argument to mrgsim (default: 256 simulation records). Increase to check less frequently, increase to check more frequently (this might be needed for a model where a large amount of work is required to advance one step) or set to negative number to never check."
  },
  {
    "objectID": "q-and-a.html#can-i-pass-compiler-flags-to-my-model",
    "href": "q-and-a.html#can-i-pass-compiler-flags-to-my-model",
    "title": "12  Questions and Answers",
    "section": "12.2 Can I pass compiler flags to my model?",
    "text": "12.2 Can I pass compiler flags to my model?\nCompiler flags can be passed to your model by setting PKG_CXXFLAGS in $ENV. For example\n\n$ENV\nPKG_CXXFLAGS = \"-std=c++11\"\n\nwill compile your model according to C++11 standard (but note that there is a special plugin that will do this automatically for you; see Section 9.4."
  },
  {
    "objectID": "q-and-a.html#can-i-compile-my-model-with-c11",
    "href": "q-and-a.html#can-i-compile-my-model-with-c11",
    "title": "12  Questions and Answers",
    "section": "12.3 Can I compile my model with C++11?",
    "text": "12.3 Can I compile my model with C++11?\nYes, you can do this by invoking the CXX11 plugin (Section 9.4)."
  },
  {
    "objectID": "q-and-a.html#how-can-i-calculate-time-after-dose",
    "href": "q-and-a.html#how-can-i-calculate-time-after-dose",
    "title": "12  Questions and Answers",
    "section": "12.4 How can I calculate time after dose?",
    "text": "12.4 How can I calculate time after dose?\nThere are three approaches\ntad argument to mrgsim()\nTo get time after dose into your output you can call\n\nmrgsim(mod, tad = TRUE)\n\nand the output will have a tad column. Note this does not let you interact with the tad value inside your model.\nSimple calculation in the model\nMost applications will call self.tad() (Section 2.3.21). For example\n\n[ main ] \ndouble tad = self.tad();\n\nMore complicated calculation in the model\nYou can get more control and track tad in a specific compartment by using the tad plugin. See Section 9.3 for details."
  },
  {
    "objectID": "q-and-a.html#my-model-failed-to-compile-what-now",
    "href": "q-and-a.html#my-model-failed-to-compile-what-now",
    "title": "12  Questions and Answers",
    "section": "12.5 My model failed to compile; what now?",
    "text": "12.5 My model failed to compile; what now?\nThe model can fail to compile for a variety of reasons, including an error in the C++ code or inability of R to find the compiler and other pieces of the tool chain.\nIf your model is not compiling, try the recover argument to mread() (or mcode())\n\nmod <- mread(..., recover = TRUE)\n\nYou will see a warning on the console and mread() will return a list of build information. You can look into that information or share it in the mrgsolve issue tracker on GitHub.\nIf your model has C++ syntax problems, the errors should be printed on the console. If you possibly have problems with the compiler or the rest of the toolchain, take a look at the pkgbuild package, which provides some helpful tools, especially if you are working on a Windows platform\n\npkgbuild::check_build_tools()\npkgbuild::has_build_tools()\npkgbuild::has_rtools()"
  },
  {
    "objectID": "q-and-a.html#can-i-run-mrgsolve-on-a-network-drive",
    "href": "q-and-a.html#can-i-run-mrgsolve-on-a-network-drive",
    "title": "12  Questions and Answers",
    "section": "12.6 Can I run mrgsolve on a network drive?",
    "text": "12.6 Can I run mrgsolve on a network drive?\nNo; do not run mrgsolve on a network drive. Your R installation, mrgsolve installation, and R working directory should be on a local hard disk."
  },
  {
    "objectID": "q-and-a.html#can-i-run-mrgsolve-on-a-cloud-synced-folder",
    "href": "q-and-a.html#can-i-run-mrgsolve-on-a-cloud-synced-folder",
    "title": "12  Questions and Answers",
    "section": "12.7 Can I run mrgsolve on a cloud-synced folder?",
    "text": "12.7 Can I run mrgsolve on a cloud-synced folder?\nNo; do not run mrgsolve in a synced folder for cloud services like OneDrive, GoogleDrive, DropBox etc. Your R installation, mrgsolve installation, and R working directory should be on a local hard disk."
  },
  {
    "objectID": "q-and-a.html#can-i-run-mrgsolve-in-a-path-that-includes-spaces",
    "href": "q-and-a.html#can-i-run-mrgsolve-in-a-path-that-includes-spaces",
    "title": "12  Questions and Answers",
    "section": "12.8 Can I run mrgsolve in a path that includes spaces?",
    "text": "12.8 Can I run mrgsolve in a path that includes spaces?\nNo; do not run mrgsolve in a path that includes spaces. Your R installation, mrgsolve installation, and R working directory should all be in locations whose paths do not include spaces."
  },
  {
    "objectID": "install.html",
    "href": "install.html",
    "title": "13  Installation",
    "section": "",
    "text": "The most up to date installation instructions can be found on our github site:\nhttps://github.com/metrumresearchgroup/mrgsolve/ https://github.com/metrumresearchgroup/mrgsolve/wiki/mrgsolve-Installation"
  }
]